# File           : cocotb-add-constrained-randomization.patch
# File Creator   : Eldridge M. Mount IV
# Content Author : Marek Cieplucha (GitHub : mciepluc <mciepluc@gmail.com>)
#
# Description    : This patch adds an entire infrastructure enabling constrained
#                  randomization and functional coverage to cocotb. This is an
#                  exceptionally powerful capability, and as such I am incorporating
#                  it temporarily via a mega-patch file while it languishes as pull
#                  request #490.
#
#                  At such time that this pull request is incorporated into the master
#                  branch of potentialventures/cocotb, this may be removed along with
#                  the corresponding patch step in the client Dockerfile(s).
#
# Source-URL     : https://github.com/potentialventures/cocotb/pull/490
#
# Diff file rendered at GitHub URL:
#
# https://patch-diff.githubusercontent.com/raw/potentialventures/cocotb/pull/490.patch


From 6966976b89aad86553af0ca3448a263bfaf3973a Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sat, 5 Mar 2016 15:44:03 +0100
Subject: [PATCH 01/13] added FC and CRV

---
 cocotb/constraint.py | 1434 ++++++++++++++++++++++++++++++++++++++++++++++++++
 cocotb/coverage.py   |  456 ++++++++++++++++
 cocotb/crv.py        |   64 +++
 3 files changed, 1954 insertions(+)
 create mode 100644 cocotb/constraint.py
 create mode 100644 cocotb/coverage.py
 create mode 100644 cocotb/crv.py

diff --git a/cocotb/constraint.py b/cocotb/constraint.py
new file mode 100644
index 00000000..b1cd836b
--- /dev/null
+++ b/cocotb/constraint.py
@@ -0,0 +1,1434 @@
+#!/usr/bin/python
+#
+# Copyright (c) 2005-2014 - Gustavo Niemeyer <gustavo@niemeyer.net>
+# 
+# All rights reserved.
+# 
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met: 
+# 
+# 1. Redistributions of source code must retain the above copyright notice, this
+#    list of conditions and the following disclaimer. 
+# 2. Redistributions in binary form must reproduce the above copyright notice,
+#    this list of conditions and the following disclaimer in the documentation
+#    and/or other materials provided with the distribution. 
+# 
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
+# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+"""
+@var Unassigned: Helper object instance representing unassigned values
+
+@sort: Problem, Variable, Domain
+@group Solvers: Solver,
+                BacktrackingSolver,
+                RecursiveBacktrackingSolver,
+                MinConflictsSolver
+@group Constraints: Constraint,
+                    FunctionConstraint,
+                    AllDifferentConstraint,
+                    AllEqualConstraint,
+                    MaxSumConstraint,
+                    ExactSumConstraint,
+                    MinSumConstraint,
+                    InSetConstraint,
+                    NotInSetConstraint,
+                    SomeInSetConstraint,
+                    SomeNotInSetConstraint
+"""
+import random
+import copy
+
+__all__ = ["Problem", "Variable", "Domain", "Unassigned",
+           "Solver", "BacktrackingSolver", "RecursiveBacktrackingSolver",
+           "MinConflictsSolver", "Constraint", "FunctionConstraint",
+           "AllDifferentConstraint", "AllEqualConstraint", "MaxSumConstraint",
+           "ExactSumConstraint", "MinSumConstraint", "InSetConstraint",
+           "NotInSetConstraint", "SomeInSetConstraint",
+           "SomeNotInSetConstraint"]
+
+class Problem(object):
+    """
+    Class used to define a problem and retrieve solutions
+    """
+
+    def __init__(self, solver=None):
+        """
+        @param solver: Problem solver used to find solutions
+                       (default is L{BacktrackingSolver})
+        @type solver:  instance of a L{Solver} subclass
+        """
+        self._solver = solver or BacktrackingSolver()
+        self._constraints = []
+        self._variables = {}
+
+    def reset(self):
+        """
+        Reset the current problem definition
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.addVariable("a", [1, 2])
+        >>> problem.reset()
+        >>> problem.getSolution()
+        >>>
+        """
+        del self._constraints[:]
+        self._variables.clear()
+
+    def setSolver(self, solver):
+        """
+        Change the problem solver currently in use
+
+        Example:
+
+        >>> solver = BacktrackingSolver()
+        >>> problem = Problem(solver)
+        >>> problem.getSolver() is solver
+        True
+
+        @param solver: New problem solver
+        @type  solver: instance of a C{Solver} subclass
+        """
+        self._solver = solver
+
+    def getSolver(self):
+        """
+        Obtain the problem solver currently in use
+
+        Example:
+
+        >>> solver = BacktrackingSolver()
+        >>> problem = Problem(solver)
+        >>> problem.getSolver() is solver
+        True
+
+        @return: Solver currently in use
+        @rtype: instance of a L{Solver} subclass
+        """
+        return self._solver
+
+    def addVariable(self, variable, domain):
+        """
+        Add a variable to the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.addVariable("a", [1, 2])
+        >>> problem.getSolution() in ({'a': 1}, {'a': 2})
+        True
+
+        @param variable: Object representing a problem variable
+        @type  variable: hashable object
+        @param domain: Set of items defining the possible values that
+                       the given variable may assume
+        @type  domain: list, tuple, or instance of C{Domain}
+        """
+        if variable in self._variables:
+            raise ValueError, "Tried to insert duplicated variable %s" % \
+                              repr(variable)
+        if type(domain) in (list, tuple):
+            domain = Domain(domain)
+        elif isinstance(domain, Domain):
+            domain = copy.copy(domain)
+        else:
+            raise TypeError, "Domains must be instances of subclasses of "\
+                             "the Domain class"
+        if not domain:
+            raise ValueError, "Domain is empty"
+        self._variables[variable] = domain
+
+    def addVariables(self, variables, domain):
+        """
+        Add one or more variables to the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.addVariables(["a", "b"], [1, 2, 3])
+        >>> solutions = problem.getSolutions()
+        >>> len(solutions)
+        9
+        >>> {'a': 3, 'b': 1} in solutions
+        True
+
+        @param variables: Any object containing a sequence of objects
+                          represeting problem variables
+        @type  variables: sequence of hashable objects
+        @param domain: Set of items defining the possible values that
+                       the given variables may assume
+        @type  domain: list, tuple, or instance of C{Domain}
+        """
+        for variable in variables:
+            self.addVariable(variable, domain)
+
+    def addConstraint(self, constraint, variables=None):
+        """
+        Add a constraint to the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.addVariables(["a", "b"], [1, 2, 3])
+        >>> problem.addConstraint(lambda a, b: b == a+1, ["a", "b"])
+        >>> solutions = problem.getSolutions()
+        >>> 
+
+        @param constraint: Constraint to be included in the problem
+        @type  constraint: instance a L{Constraint} subclass or a
+                           function to be wrapped by L{FunctionConstraint}
+        @param variables: Variables affected by the constraint (default to
+                          all variables). Depending on the constraint type
+                          the order may be important.
+        @type  variables: set or sequence of variables
+        """
+        if not isinstance(constraint, Constraint):
+            if callable(constraint):
+                constraint = FunctionConstraint(constraint)
+            else:
+                raise ValueError, "Constraints must be instances of "\
+                                  "subclasses of the Constraint class"
+        self._constraints.append((constraint, variables))
+
+    def getSolution(self):
+        """
+        Find and return a solution to the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.getSolution() is None
+        True
+        >>> problem.addVariables(["a"], [42])
+        >>> problem.getSolution()
+        {'a': 42}
+
+        @return: Solution for the problem
+        @rtype: dictionary mapping variables to values
+        """
+        domains, constraints, vconstraints = self._getArgs()
+        if not domains:
+            return None
+        return self._solver.getSolution(domains, constraints, vconstraints)
+
+    def getSolutions(self):
+        """
+        Find and return all solutions to the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> problem.getSolutions() == []
+        True
+        >>> problem.addVariables(["a"], [42])
+        >>> problem.getSolutions()
+        [{'a': 42}]
+
+        @return: All solutions for the problem
+        @rtype: list of dictionaries mapping variables to values
+        """
+        domains, constraints, vconstraints = self._getArgs()
+        if not domains:
+            return []
+        return self._solver.getSolutions(domains, constraints, vconstraints)
+
+    def getSolutionIter(self):
+        """
+        Return an iterator to the solutions of the problem
+
+        Example:
+
+        >>> problem = Problem()
+        >>> list(problem.getSolutionIter()) == []
+        True
+        >>> problem.addVariables(["a"], [42])
+        >>> iter = problem.getSolutionIter()
+        >>> iter.next()
+        {'a': 42}
+        >>> iter.next()
+        Traceback (most recent call last):
+          File "<stdin>", line 1, in ?
+        StopIteration
+        """
+        domains, constraints, vconstraints = self._getArgs()
+        if not domains:
+            return iter(())
+        return self._solver.getSolutionIter(domains, constraints,
+                                            vconstraints)
+
+    def _getArgs(self):
+        domains = self._variables.copy()
+        allvariables = domains.keys()
+        constraints = []
+        for constraint, variables in self._constraints:
+            if not variables:
+                variables = allvariables
+            constraints.append((constraint, variables))
+        vconstraints = {}
+        for variable in domains:
+            vconstraints[variable] = []
+        for constraint, variables in constraints:
+            for variable in variables:
+                vconstraints[variable].append((constraint, variables))
+        for constraint, variables in constraints[:]:
+            constraint.preProcess(variables, domains,
+                                  constraints, vconstraints)
+        for domain in domains.values():
+            domain.resetState()
+            if not domain:
+                return None, None, None
+        #doArc8(getArcs(domains, constraints), domains, {})
+        return domains, constraints, vconstraints
+
+# ----------------------------------------------------------------------
+# Solvers
+# ----------------------------------------------------------------------
+
+def getArcs(domains, constraints):
+    """
+    Return a dictionary mapping pairs (arcs) of constrained variables
+
+    @attention: Currently unused.
+    """
+    arcs = {}
+    for x in constraints:
+        constraint, variables = x
+        if len(variables) == 2:
+            variable1, variable2 = variables
+            arcs.setdefault(variable1, {})\
+                .setdefault(variable2, [])\
+                .append(x)
+            arcs.setdefault(variable2, {})\
+                .setdefault(variable1, [])\
+                .append(x)
+    return arcs
+
+def doArc8(arcs, domains, assignments):
+    """
+    Perform the ARC-8 arc checking algorithm and prune domains
+
+    @attention: Currently unused.
+    """
+    check = dict.fromkeys(domains, True)
+    while check:
+        variable, _ = check.popitem()
+        if variable not in arcs or variable in assignments:
+            continue
+        domain = domains[variable]
+        arcsvariable = arcs[variable]
+        for othervariable in arcsvariable:
+            arcconstraints = arcsvariable[othervariable]
+            if othervariable in assignments:
+                otherdomain = [assignments[othervariable]]
+            else:
+                otherdomain = domains[othervariable]
+            if domain:
+                changed = False
+                for value in domain[:]:
+                    assignments[variable] = value
+                    if otherdomain:
+                        for othervalue in otherdomain:
+                            assignments[othervariable] = othervalue
+                            for constraint, variables in arcconstraints:
+                                if not constraint(variables, domains,
+                                                  assignments, True):
+                                    break
+                            else:
+                                # All constraints passed. Value is safe.
+                                break
+                        else:
+                            # All othervalues failed. Kill value.
+                            domain.hideValue(value)
+                            changed = True
+                        del assignments[othervariable]
+                del assignments[variable]
+                #if changed:
+                #    check.update(dict.fromkeys(arcsvariable))
+            if not domain:
+                return False
+    return True
+
+class Solver(object):
+    """
+    Abstract base class for solvers
+
+    @sort: getSolution, getSolutions, getSolutionIter
+    """
+
+    def getSolution(self, domains, constraints, vconstraints):
+        """
+        Return one solution for the given problem
+
+        @param domains: Dictionary mapping variables to their domains
+        @type  domains: dict
+        @param constraints: List of pairs of (constraint, variables)
+        @type  constraints: list
+        @param vconstraints: Dictionary mapping variables to a list of
+                             constraints affecting the given variables.
+        @type  vconstraints: dict
+        """
+        raise NotImplementedError, \
+              "%s is an abstract class" % self.__class__.__name__
+
+    def getSolutions(self, domains, constraints, vconstraints):
+        """
+        Return all solutions for the given problem
+
+        @param domains: Dictionary mapping variables to domains
+        @type  domains: dict
+        @param constraints: List of pairs of (constraint, variables)
+        @type  constraints: list
+        @param vconstraints: Dictionary mapping variables to a list of
+                             constraints affecting the given variables.
+        @type  vconstraints: dict
+        """
+        raise NotImplementedError, \
+              "%s provides only a single solution" % self.__class__.__name__
+
+    def getSolutionIter(self, domains, constraints, vconstraints):
+        """
+        Return an iterator for the solutions of the given problem
+
+        @param domains: Dictionary mapping variables to domains
+        @type  domains: dict
+        @param constraints: List of pairs of (constraint, variables)
+        @type  constraints: list
+        @param vconstraints: Dictionary mapping variables to a list of
+                             constraints affecting the given variables.
+        @type  vconstraints: dict
+        """
+        raise NotImplementedError, \
+              "%s doesn't provide iteration" % self.__class__.__name__
+
+class BacktrackingSolver(Solver):
+    """
+    Problem solver with backtracking capabilities
+
+    Examples:
+
+    >>> result = [[('a', 1), ('b', 2)],
+    ...           [('a', 1), ('b', 3)],
+    ...           [('a', 2), ('b', 3)]]
+
+    >>> problem = Problem(BacktrackingSolver())
+    >>> problem.addVariables(["a", "b"], [1, 2, 3])
+    >>> problem.addConstraint(lambda a, b: b > a, ["a", "b"])
+
+    >>> solution = problem.getSolution()
+    >>> sorted(solution.items()) in result
+    True
+
+    >>> for solution in problem.getSolutionIter():
+    ...     sorted(solution.items()) in result
+    True
+    True
+    True
+
+    >>> for solution in problem.getSolutions():
+    ...     sorted(solution.items()) in result
+    True
+    True
+    True
+    """#"""
+
+    def __init__(self, forwardcheck=True):
+        """
+        @param forwardcheck: If false forward checking will not be requested
+                             to constraints while looking for solutions
+                             (default is true)
+        @type  forwardcheck: bool
+        """
+        self._forwardcheck = forwardcheck
+
+    def getSolutionIter(self, domains, constraints, vconstraints):
+        forwardcheck = self._forwardcheck
+        assignments = {}
+
+        queue = []
+
+        while True:
+
+            # Mix the Degree and Minimum Remaing Values (MRV) heuristics
+            lst = [(-len(vconstraints[variable]),
+                    len(domains[variable]), variable) for variable in domains]
+            lst.sort()
+            for item in lst:
+                if item[-1] not in assignments:
+                    # Found unassigned variable
+                    variable = item[-1]
+                    values = domains[variable][:]
+                    if forwardcheck:
+                        pushdomains = [domains[x] for x in domains
+                                                   if x not in assignments and
+                                                      x != variable]
+                    else:
+                        pushdomains = None
+                    break
+            else:
+                # No unassigned variables. We've got a solution. Go back
+                # to last variable, if there's one.
+                yield assignments.copy()
+                if not queue:
+                    return
+                variable, values, pushdomains = queue.pop()
+                if pushdomains:
+                    for domain in pushdomains:
+                        domain.popState()
+
+            while True:
+                # We have a variable. Do we have any values left?
+                if not values:
+                    # No. Go back to last variable, if there's one.
+                    del assignments[variable]
+                    while queue:
+                        variable, values, pushdomains = queue.pop()
+                        if pushdomains:
+                            for domain in pushdomains:
+                                domain.popState()
+                        if values:
+                            break
+                        del assignments[variable]
+                    else:
+                        return
+
+                # Got a value. Check it.
+                assignments[variable] = values.pop()
+
+                if pushdomains:
+                    for domain in pushdomains:
+                        domain.pushState()
+
+                for constraint, variables in vconstraints[variable]:
+                    if not constraint(variables, domains, assignments,
+                                      pushdomains):
+                        # Value is not good.
+                        break
+                else:
+                    break
+
+                if pushdomains:
+                    for domain in pushdomains:
+                        domain.popState()
+
+            # Push state before looking for next variable.
+            queue.append((variable, values, pushdomains))
+
+        raise RuntimeError, "Can't happen"
+
+    def getSolution(self, domains, constraints, vconstraints):
+        iter = self.getSolutionIter(domains, constraints, vconstraints)
+        try:
+            return iter.next()
+        except StopIteration:
+            return None
+
+    def getSolutions(self, domains, constraints, vconstraints):
+        return list(self.getSolutionIter(domains, constraints, vconstraints))
+
+
+class RecursiveBacktrackingSolver(Solver):
+    """
+    Recursive problem solver with backtracking capabilities
+
+    Examples:
+
+    >>> result = [[('a', 1), ('b', 2)],
+    ...           [('a', 1), ('b', 3)],
+    ...           [('a', 2), ('b', 3)]]
+
+    >>> problem = Problem(RecursiveBacktrackingSolver())
+    >>> problem.addVariables(["a", "b"], [1, 2, 3])
+    >>> problem.addConstraint(lambda a, b: b > a, ["a", "b"])
+
+    >>> solution = problem.getSolution()
+    >>> sorted(solution.items()) in result
+    True
+
+    >>> for solution in problem.getSolutions():
+    ...     sorted(solution.items()) in result
+    True
+    True
+    True
+
+    >>> problem.getSolutionIter()
+    Traceback (most recent call last):
+       ...
+    NotImplementedError: RecursiveBacktrackingSolver doesn't provide iteration
+    """#"""
+
+    def __init__(self, forwardcheck=True):
+        """
+        @param forwardcheck: If false forward checking will not be requested
+                             to constraints while looking for solutions
+                             (default is true)
+        @type  forwardcheck: bool
+        """
+        self._forwardcheck = forwardcheck
+
+    def recursiveBacktracking(self, solutions, domains, vconstraints,
+                              assignments, single):
+
+        # Mix the Degree and Minimum Remaing Values (MRV) heuristics
+        lst = [(-len(vconstraints[variable]),
+                len(domains[variable]), variable) for variable in domains]
+        lst.sort()
+        for item in lst:
+            if item[-1] not in assignments:
+                # Found an unassigned variable. Let's go.
+                break
+        else:
+            # No unassigned variables. We've got a solution.
+            solutions.append(assignments.copy())
+            return solutions
+
+        variable = item[-1]
+        assignments[variable] = None
+
+        forwardcheck = self._forwardcheck
+        if forwardcheck:
+            pushdomains = [domains[x] for x in domains if x not in assignments]
+        else:
+            pushdomains = None
+
+        for value in domains[variable]:
+            assignments[variable] = value
+            if pushdomains:
+                for domain in pushdomains:
+                    domain.pushState()
+            for constraint, variables in vconstraints[variable]:
+                if not constraint(variables, domains, assignments,
+                                  pushdomains):
+                    # Value is not good.
+                    break
+            else:
+                # Value is good. Recurse and get next variable.
+                self.recursiveBacktracking(solutions, domains, vconstraints,
+                                           assignments, single)
+                if solutions and single:
+                    return solutions
+            if pushdomains:
+                for domain in pushdomains:
+                    domain.popState()
+        del assignments[variable]
+        return solutions
+
+    def getSolution(self, domains, constraints, vconstraints):
+        solutions = self.recursiveBacktracking([], domains, vconstraints,
+                                               {}, True)
+        return solutions and solutions[0] or None
+
+    def getSolutions(self, domains, constraints, vconstraints):
+        return self.recursiveBacktracking([], domains, vconstraints,
+                                          {}, False)
+
+
+class MinConflictsSolver(Solver):
+    """
+    Problem solver based on the minimum conflicts theory
+
+    Examples:
+
+    >>> result = [[('a', 1), ('b', 2)],
+    ...           [('a', 1), ('b', 3)],
+    ...           [('a', 2), ('b', 3)]]
+
+    >>> problem = Problem(MinConflictsSolver())
+    >>> problem.addVariables(["a", "b"], [1, 2, 3])
+    >>> problem.addConstraint(lambda a, b: b > a, ["a", "b"])
+
+    >>> solution = problem.getSolution()
+    >>> sorted(solution.items()) in result
+    True
+
+    >>> problem.getSolutions()
+    Traceback (most recent call last):
+       ...
+    NotImplementedError: MinConflictsSolver provides only a single solution
+
+    >>> problem.getSolutionIter()
+    Traceback (most recent call last):
+       ...
+    NotImplementedError: MinConflictsSolver doesn't provide iteration
+    """#"""
+
+    def __init__(self, steps=1000):
+        """
+        @param steps: Maximum number of steps to perform before giving up
+                      when looking for a solution (default is 1000)
+        @type  steps: int
+        """
+        self._steps = steps
+
+    def getSolution(self, domains, constraints, vconstraints):
+        assignments = {}
+        # Initial assignment
+        for variable in domains:
+            assignments[variable] = random.choice(domains[variable])
+        for _ in xrange(self._steps):
+            conflicted = False
+            lst = domains.keys()
+            random.shuffle(lst)
+            for variable in lst:
+                # Check if variable is not in conflict
+                for constraint, variables in vconstraints[variable]:
+                    if not constraint(variables, domains, assignments):
+                        break
+                else:
+                    continue
+                # Variable has conflicts. Find values with less conflicts.
+                mincount = len(vconstraints[variable])
+                minvalues = []
+                for value in domains[variable]:
+                    assignments[variable] = value
+                    count = 0
+                    for constraint, variables in vconstraints[variable]:
+                        if not constraint(variables, domains, assignments):
+                            count += 1
+                    if count == mincount:
+                        minvalues.append(value)
+                    elif count < mincount:
+                        mincount = count
+                        del minvalues[:]
+                        minvalues.append(value)
+                # Pick a random one from these values.
+                assignments[variable] = random.choice(minvalues)
+                conflicted = True
+            if not conflicted:
+                return assignments
+        return None
+
+# ----------------------------------------------------------------------
+# Variables
+# ----------------------------------------------------------------------
+
+class Variable(object):
+    """
+    Helper class for variable definition
+
+    Using this class is optional, since any hashable object,
+    including plain strings and integers, may be used as variables.
+    """
+
+    def __init__(self, name):
+        """
+        @param name: Generic variable name for problem-specific purposes
+        @type  name: string
+        """
+        self.name = name
+
+    def __repr__(self):
+        return self.name
+
+Unassigned = Variable("Unassigned")
+
+# ----------------------------------------------------------------------
+# Domains
+# ----------------------------------------------------------------------
+
+class Domain(list):
+    """
+    Class used to control possible values for variables
+
+    When list or tuples are used as domains, they are automatically
+    converted to an instance of that class.
+    """
+
+    def __init__(self, set):
+        """
+        @param set: Set of values that the given variables may assume
+        @type  set: set of objects comparable by equality
+        """
+        list.__init__(self, set)
+        self._hidden = []
+        self._states = []
+
+    def resetState(self):
+        """
+        Reset to the original domain state, including all possible values
+        """
+        self.extend(self._hidden)
+        del self._hidden[:]
+        del self._states[:]
+
+    def pushState(self):
+        """
+        Save current domain state
+        
+        Variables hidden after that call are restored when that state
+        is popped from the stack.
+        """
+        self._states.append(len(self))
+
+    def popState(self):
+        """
+        Restore domain state from the top of the stack
+
+        Variables hidden since the last popped state are then available
+        again.
+        """
+        diff = self._states.pop()-len(self)
+        if diff:
+            self.extend(self._hidden[-diff:])
+            del self._hidden[-diff:]
+
+    def hideValue(self, value):
+        """
+        Hide the given value from the domain
+
+        After that call the given value won't be seen as a possible value
+        on that domain anymore. The hidden value will be restored when the
+        previous saved state is popped.
+
+        @param value: Object currently available in the domain
+        """
+        list.remove(self, value)
+        self._hidden.append(value)
+
+# ----------------------------------------------------------------------
+# Constraints
+# ----------------------------------------------------------------------
+
+class Constraint(object):
+    """
+    Abstract base class for constraints
+    """ 
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        """
+        Perform the constraint checking
+
+        If the forwardcheck parameter is not false, besides telling if
+        the constraint is currently broken or not, the constraint
+        implementation may choose to hide values from the domains of
+        unassigned variables to prevent them from being used, and thus
+        prune the search space.
+
+        @param variables: Variables affected by that constraint, in the
+                          same order provided by the user
+        @type  variables: sequence
+        @param domains: Dictionary mapping variables to their domains
+        @type  domains: dict
+        @param assignments: Dictionary mapping assigned variables to their
+                            current assumed value
+        @type  assignments: dict
+        @param forwardcheck: Boolean value stating whether forward checking
+                             should be performed or not
+        @return: Boolean value stating if this constraint is currently
+                 broken or not
+        @rtype: bool
+        """#"""
+        return True
+
+    def preProcess(self, variables, domains, constraints, vconstraints):
+        """
+        Preprocess variable domains
+
+        This method is called before starting to look for solutions,
+        and is used to prune domains with specific constraint logic
+        when possible. For instance, any constraints with a single
+        variable may be applied on all possible values and removed,
+        since they may act on individual values even without further
+        knowledge about other assignments.
+
+        @param variables: Variables affected by that constraint, in the
+                          same order provided by the user
+        @type  variables: sequence
+        @param domains: Dictionary mapping variables to their domains
+        @type  domains: dict
+        @param constraints: List of pairs of (constraint, variables)
+        @type  constraints: list
+        @param vconstraints: Dictionary mapping variables to a list of
+                             constraints affecting the given variables.
+        @type  vconstraints: dict
+        """#"""
+        if len(variables) == 1:
+            variable = variables[0]
+            domain = domains[variable]
+            for value in domain[:]:
+                if not self(variables, domains, {variable: value}):
+                    domain.remove(value)
+            constraints.remove((self, variables))
+            vconstraints[variable].remove((self, variables))
+
+    def forwardCheck(self, variables, domains, assignments,
+                     _unassigned=Unassigned):
+        """
+        Helper method for generic forward checking
+
+        Currently, this method acts only when there's a single
+        unassigned variable.
+
+        @param variables: Variables affected by that constraint, in the
+                          same order provided by the user
+        @type  variables: sequence
+        @param domains: Dictionary mapping variables to their domains
+        @type  domains: dict
+        @param assignments: Dictionary mapping assigned variables to their
+                            current assumed value
+        @type  assignments: dict
+        @return: Boolean value stating if this constraint is currently
+                 broken or not
+        @rtype: bool
+        """#"""
+        unassignedvariable = _unassigned
+        for variable in variables:
+            if variable not in assignments:
+                if unassignedvariable is _unassigned:
+                    unassignedvariable = variable
+                else:
+                    break
+        else:
+            if unassignedvariable is not _unassigned:
+                # Remove from the unassigned variable domain's all
+                # values which break our variable's constraints.
+                domain = domains[unassignedvariable]
+                if domain:
+                    for value in domain[:]:
+                        assignments[unassignedvariable] = value
+                        if not self(variables, domains, assignments):
+                            domain.hideValue(value)
+                    del assignments[unassignedvariable]
+                if not domain:
+                    return False
+        return True
+
+class FunctionConstraint(Constraint):
+    """
+    Constraint which wraps a function defining the constraint logic
+
+    Examples:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> def func(a, b):
+    ...     return b > a
+    >>> problem.addConstraint(func, ["a", "b"])
+    >>> problem.getSolution()
+    {'a': 1, 'b': 2}
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> def func(a, b):
+    ...     return b > a
+    >>> problem.addConstraint(FunctionConstraint(func), ["a", "b"])
+    >>> problem.getSolution()
+    {'a': 1, 'b': 2}
+    """#"""
+ 
+    def __init__(self, func, assigned=True):
+        """
+        @param func: Function wrapped and queried for constraint logic
+        @type  func: callable object
+        @param assigned: Whether the function may receive unassigned
+                         variables or not
+        @type  assigned: bool
+        """
+        self._func = func
+        self._assigned = assigned
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False,
+                 _unassigned=Unassigned):
+        parms = [assignments.get(x, _unassigned) for x in variables]
+        missing = parms.count(_unassigned)
+        if missing:
+            return ((self._assigned or self._func(*parms)) and
+                    (not forwardcheck or missing != 1 or
+                     self.forwardCheck(variables, domains, assignments)))
+        return self._func(*parms)
+
+class AllDifferentConstraint(Constraint):
+    """
+    Constraint enforcing that values of all given variables are different
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(AllDifferentConstraint())
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 2)], [('a', 2), ('b', 1)]]
+    """#"""
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False,
+                 _unassigned=Unassigned):
+        seen = {}
+        for variable in variables:
+            value = assignments.get(variable, _unassigned)
+            if value is not _unassigned:
+                if value in seen:
+                    return False
+                seen[value] = True
+        if forwardcheck:
+            for variable in variables:
+                if variable not in assignments:
+                    domain = domains[variable]
+                    for value in seen:
+                        if value in domain:
+                            domain.hideValue(value)
+                            if not domain:
+                                return False
+        return True
+
+class AllEqualConstraint(Constraint):
+    """
+    Constraint enforcing that values of all given variables are equal
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(AllEqualConstraint())
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 1)], [('a', 2), ('b', 2)]]
+    """#"""
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False,
+                 _unassigned=Unassigned):
+        singlevalue = _unassigned
+        for variable in variables:
+            value = assignments.get(variable, _unassigned)
+            if singlevalue is _unassigned:
+                singlevalue = value
+            elif value is not _unassigned and value != singlevalue:
+                return False
+        if forwardcheck and singlevalue is not _unassigned:
+            for variable in variables:
+                if variable not in assignments:
+                    domain = domains[variable]
+                    if singlevalue not in domain:
+                        return False
+                    for value in domain[:]:
+                        if value != singlevalue:
+                            domain.hideValue(value)
+        return True
+
+class MaxSumConstraint(Constraint):
+    """
+    Constraint enforcing that values of given variables sum up to
+    a given amount
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(MaxSumConstraint(3))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 1)], [('a', 1), ('b', 2)], [('a', 2), ('b', 1)]]
+    """#"""
+
+    def __init__(self, maxsum, multipliers=None):
+        """
+        @param maxsum: Value to be considered as the maximum sum
+        @type  maxsum: number
+        @param multipliers: If given, variable values will be multiplied by
+                            the given factors before being summed to be checked
+        @type  multipliers: sequence of numbers
+        """
+        self._maxsum = maxsum
+        self._multipliers = multipliers
+
+    def preProcess(self, variables, domains, constraints, vconstraints):
+        Constraint.preProcess(self, variables, domains,
+                              constraints, vconstraints)
+        multipliers = self._multipliers
+        maxsum = self._maxsum
+        if multipliers:
+            for variable, multiplier in zip(variables, multipliers):
+                domain = domains[variable]
+                for value in domain[:]:
+                    if value*multiplier > maxsum:
+                        domain.remove(value)
+        else:
+            for variable in variables:
+                domain = domains[variable]
+                for value in domain[:]:
+                    if value > maxsum:
+                        domain.remove(value)
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        multipliers = self._multipliers
+        maxsum = self._maxsum
+        sum = 0
+        if multipliers:
+            for variable, multiplier in zip(variables, multipliers):
+                if variable in assignments:
+                    sum += assignments[variable]*multiplier
+            if type(sum) is float:
+                sum = round(sum, 10)
+            if sum > maxsum:
+                return False
+            if forwardcheck:
+                for variable, multiplier in zip(variables, multipliers):
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if sum+value*multiplier > maxsum:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        else:
+            for variable in variables:
+                if variable in assignments:
+                    sum += assignments[variable]
+            if type(sum) is float:
+                sum = round(sum, 10)
+            if sum > maxsum:
+                return False
+            if forwardcheck:
+                for variable in variables:
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if sum+value > maxsum:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        return True
+
+class ExactSumConstraint(Constraint):
+    """
+    Constraint enforcing that values of given variables sum exactly
+    to a given amount
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(ExactSumConstraint(3))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 2)], [('a', 2), ('b', 1)]]
+    """#"""
+
+    def __init__(self, exactsum, multipliers=None):
+        """
+        @param exactsum: Value to be considered as the exact sum
+        @type  exactsum: number
+        @param multipliers: If given, variable values will be multiplied by
+                            the given factors before being summed to be checked
+        @type  multipliers: sequence of numbers
+        """
+        self._exactsum = exactsum
+        self._multipliers = multipliers
+
+    def preProcess(self, variables, domains, constraints, vconstraints):
+        Constraint.preProcess(self, variables, domains,
+                              constraints, vconstraints)
+        multipliers = self._multipliers
+        exactsum = self._exactsum
+        if multipliers:
+            for variable, multiplier in zip(variables, multipliers):
+                domain = domains[variable]
+                for value in domain[:]:
+                    if value*multiplier > exactsum:
+                        domain.remove(value)
+        else:
+            for variable in variables:
+                domain = domains[variable]
+                for value in domain[:]:
+                    if value > exactsum:
+                        domain.remove(value)
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        multipliers = self._multipliers
+        exactsum = self._exactsum
+        sum = 0
+        missing = False
+        if multipliers:
+            for variable, multiplier in zip(variables, multipliers):
+                if variable in assignments:
+                    sum += assignments[variable]*multiplier
+                else:
+                    missing = True
+            if type(sum) is float:
+                sum = round(sum, 10)
+            if sum > exactsum:
+                return False
+            if forwardcheck and missing:
+                for variable, multiplier in zip(variables, multipliers):
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if sum+value*multiplier > exactsum:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        else:
+            for variable in variables:
+                if variable in assignments:
+                    sum += assignments[variable]
+                else:
+                    missing = True
+            if type(sum) is float:
+                sum = round(sum, 10)
+            if sum > exactsum:
+                return False
+            if forwardcheck and missing:
+                for variable in variables:
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if sum+value > exactsum:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        if missing:
+            return sum <= exactsum
+        else:
+            return sum == exactsum
+
+class MinSumConstraint(Constraint):
+    """
+    Constraint enforcing that values of given variables sum at least
+    to a given amount
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(MinSumConstraint(3))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 2)], [('a', 2), ('b', 1)], [('a', 2), ('b', 2)]]
+    """#"""
+
+    def __init__(self, minsum, multipliers=None):
+        """
+        @param minsum: Value to be considered as the minimum sum
+        @type  minsum: number
+        @param multipliers: If given, variable values will be multiplied by
+                            the given factors before being summed to be checked
+        @type  multipliers: sequence of numbers
+        """
+        self._minsum = minsum
+        self._multipliers = multipliers
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        for variable in variables:
+            if variable not in assignments:
+                return True
+        else:
+            multipliers = self._multipliers
+            minsum = self._minsum
+            sum = 0
+            if multipliers:
+                for variable, multiplier in zip(variables, multipliers):
+                    sum += assignments[variable]*multiplier
+            else:
+                for variable in variables:
+                    sum += assignments[variable]
+            if type(sum) is float:
+                sum = round(sum, 10)
+            return sum >= minsum
+
+class InSetConstraint(Constraint):
+    """
+    Constraint enforcing that values of given variables are present in
+    the given set
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(InSetConstraint([1]))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 1)]]
+    """#"""
+
+    def __init__(self, set):
+        """
+        @param set: Set of allowed values
+        @type  set: set
+        """
+        self._set = set
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        # preProcess() will remove it.
+        raise RuntimeError, "Can't happen"
+
+    def preProcess(self, variables, domains, constraints, vconstraints):
+        set = self._set
+        for variable in variables:
+            domain = domains[variable]
+            for value in domain[:]:
+                if value not in set:
+                    domain.remove(value)
+            vconstraints[variable].remove((self, variables))
+        constraints.remove((self, variables))
+
+class NotInSetConstraint(Constraint):
+    """
+    Constraint enforcing that values of given variables are not present in
+    the given set
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(NotInSetConstraint([1]))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 2), ('b', 2)]]
+    """#"""
+
+    def __init__(self, set):
+        """
+        @param set: Set of disallowed values
+        @type  set: set
+        """
+        self._set = set
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        # preProcess() will remove it.
+        raise RuntimeError, "Can't happen"
+
+    def preProcess(self, variables, domains, constraints, vconstraints):
+        set = self._set
+        for variable in variables:
+            domain = domains[variable]
+            for value in domain[:]:
+                if value in set:
+                    domain.remove(value)
+            vconstraints[variable].remove((self, variables))
+        constraints.remove((self, variables))
+
+class SomeInSetConstraint(Constraint):
+    """
+    Constraint enforcing that at least some of the values of given
+    variables must be present in a given set
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(SomeInSetConstraint([1]))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 1)], [('a', 1), ('b', 2)], [('a', 2), ('b', 1)]]
+    """#"""
+
+    def __init__(self, set, n=1, exact=False):
+        """
+        @param set: Set of values to be checked
+        @type  set: set
+        @param n: Minimum number of assigned values that should be present
+                  in set (default is 1)
+        @type  n: int
+        @param exact: Whether the number of assigned values which are
+                      present in set must be exactly C{n}
+        @type  exact: bool
+        """
+        self._set = set
+        self._n = n
+        self._exact = exact
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        set = self._set
+        missing = 0
+        found = 0
+        for variable in variables:
+            if variable in assignments:
+                found += assignments[variable] in set
+            else:
+                missing += 1
+        if missing:
+            if self._exact:
+                if not (found <= self._n <= missing+found):
+                    return False
+            else:
+                if self._n > missing+found:
+                    return False
+            if forwardcheck and self._n-found == missing:
+                # All unassigned variables must be assigned to
+                # values in the set.
+                for variable in variables:
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if value not in set:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        else:
+            if self._exact:
+                if found != self._n:
+                    return False
+            else:
+                if found < self._n:
+                    return False
+        return True
+
+class SomeNotInSetConstraint(Constraint):
+    """
+    Constraint enforcing that at least some of the values of given
+    variables must not be present in a given set
+
+    Example:
+
+    >>> problem = Problem()
+    >>> problem.addVariables(["a", "b"], [1, 2])
+    >>> problem.addConstraint(SomeNotInSetConstraint([1]))
+    >>> sorted(sorted(x.items()) for x in problem.getSolutions())
+    [[('a', 1), ('b', 2)], [('a', 2), ('b', 1)], [('a', 2), ('b', 2)]]
+    """#"""
+
+    def __init__(self, set, n=1, exact=False):
+        """
+        @param set: Set of values to be checked
+        @type  set: set
+        @param n: Minimum number of assigned values that should not be present
+                  in set (default is 1)
+        @type  n: int
+        @param exact: Whether the number of assigned values which are
+                      not present in set must be exactly C{n}
+        @type  exact: bool
+        """
+        self._set = set
+        self._n = n
+        self._exact = exact
+
+    def __call__(self, variables, domains, assignments, forwardcheck=False):
+        set = self._set
+        missing = 0
+        found = 0
+        for variable in variables:
+            if variable in assignments:
+                found += assignments[variable] not in set
+            else:
+                missing += 1
+        if missing:
+            if self._exact:
+                if not (found <= self._n <= missing+found):
+                    return False
+            else:
+                if self._n > missing+found:
+                    return False
+            if forwardcheck and self._n-found == missing:
+                # All unassigned variables must be assigned to
+                # values not in the set.
+                for variable in variables:
+                    if variable not in assignments:
+                        domain = domains[variable]
+                        for value in domain[:]:
+                            if value in set:
+                                domain.hideValue(value)
+                        if not domain:
+                            return False
+        else:
+            if self._exact:
+                if found != self._n:
+                    return False
+            else:
+                if found < self._n:
+                    return False
+        return True
+
+if __name__ == "__main__":
+    import doctest
+    doctest.testmod()
+
diff --git a/cocotb/coverage.py b/cocotb/coverage.py
new file mode 100644
index 00000000..b0cd7948
--- /dev/null
+++ b/cocotb/coverage.py
@@ -0,0 +1,456 @@
+
+"""
+Functional Coverage features.
+Global variable:
+coverage_db - a coverage prefix tree (map) containing all coverage objects with name string as a key
+
+Classes:
+CoverItem  - coverage base class, corresponds to a covergroup, created automatically
+CoverPoint - a cover point with bins
+CoverCross - a cover cross with references to CoverPoints
+CoverCheck - a cover point which checks only a pass/fail condition
+"""
+
+from functools import wraps
+from collections import OrderedDict
+import inspect
+import operator
+import itertools
+
+# global variable collecting coverage in a prefix tree (trie)
+coverage_db = {}
+            
+class CoverItem(object):
+    """
+    Class used to describe coverage groups.
+    CoverItem objects are created automatically. 
+    """
+    def __init__(self, name):
+        self._name = name
+        self._size = 0
+        self._coverage = 0
+        self._parent = None
+        self._children = []
+        
+        self._threshold_callbacks = {}
+        self._bins_callbacks = {}
+                
+        #check if parent exists
+        if "." in name:
+            parent_name=".".join(name.split(".")[:-1])
+            if not parent_name in coverage_db:
+                CoverItem(name=parent_name)
+                
+            self._parent = coverage_db[parent_name]
+            self._parent._children.append(self)
+                
+        coverage_db[name] = self
+    
+    def _update_coverage(self, coverage):
+        current_coverage = self._coverage
+        self._coverage += coverage
+        if self._parent is not None:
+            self._parent._update_coverage(coverage) 
+            
+        #notify callbacks
+        for ii in self._threshold_callbacks:
+            if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
+                self._threshold_callbacks[ii]() 
+                
+    def _update_size(self, size):
+        self._size += size
+        if self._parent is not None:
+            self._parent._update_size(size) 
+        
+    def add_threshold_callback(self, callback, threshold):
+        self._threshold_callbacks[threshold] = callback
+        
+    def add_bins_callback(self, callback, bins):
+        self._bins_callbacks[bins] = callback
+        
+    @property
+    def size(self):
+        return self._size
+        
+    @property
+    def coverage(self):
+        return self._coverage
+    
+    @property
+    def detailed_coverage(self):
+        coverage = []
+        for child in self._children:
+            coverage.append(child.detailed_coverage)
+        return coverage
+        
+class CoverPoint(CoverItem):
+    """
+    Class used to create coverage points as decorators. It matches predefined bins
+    according to the rule rel(f(args), bin) == True 
+    Syntax:
+    @coverage.CoverPoint(name, f, rel, bins, weight, at_least, inj)
+    Where:
+    name - a CoverPoint path and name, defining its position in a coverage trie
+    f - (optional) transformation function, which transforms arguments of the decorated function (args)
+    rel - (optional) relation function which defines bins matching relation (by default equality operator)
+    bins - a list of bins objects to be matched
+    weight - (optional) a CoverPoint weight (by default 1)
+    at_least - (optional) defines number of hits per bin to be considered as covered (by default 1)
+    inj - (optional) defines if more than single bin can be matched at one sampling (default False)
+    
+    Example:
+    @coverage.CoverPoint(
+      name = "top.parent.coverpoint", 
+      f = lambda x : x/2, 
+      rel = lambda x, y : x < y, 
+      bins = range(1,5)
+    )
+    def decorated_fun(self, arg):
+      ...
+    Bin from the bins list [1,2,3,4,5] will be matched when arg/2 < bin at decorated_fun call.
+    """
+    
+    #conditional Object creation, only if name not already registered
+    def __new__(cls, name, f=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+        if name in coverage_db:
+            return coverage_db[name]
+        else:
+            return super(CoverPoint, cls).__new__(CoverPoint)
+
+    def __init__(self, name, f=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+        if not name in coverage_db:
+            CoverItem.__init__(self, name)
+            self._transformation = f
+            #equality operator is the defult bins matching relation
+            self._relation = rel if rel is not None else operator.eq
+            self._weight = weight
+            self._at_least = at_least
+            self._injection = inj
+                        
+            if (len(bins) != 0): 
+                self._size = self._weight*len(bins)
+                self._hits = OrderedDict.fromkeys(bins, 0)
+            else: #if no bins specified, add one bin equal True
+                self._size = self._weight
+                self._hits = OrderedDict.fromkeys([True], 0)
+            
+            self._decorates_method = None #determines whether decorated a bound method
+            self._trans_is_method = None #determines whether transformation function is a bound method
+            self._parent._update_size(self._size)
+            
+            self._new_hits = [] #list of bins hit per single function call
+
+    def __call__(self, f):
+        @wraps(f)
+        def _wrapped_function(*cb_args, **cb_kwargs):
+            
+            #if transformation function not defined, simply return arguments
+            if self._transformation is None:
+                def dummy_f(*cb_args): #return a tuple or single object
+                    if len(cb_args) > 1:
+                        return cb_args
+                    else:
+                        return cb_args[0]
+                self._transformation = dummy_f
+                
+            #for the first time only check if decorates method in the class
+            if self._decorates_method is None:
+                self._decorates_method = False
+                for x in inspect.getmembers(cb_args[0]):
+                    if '__func__' in dir(x[1]):
+                        #compare decorated function name with class functions
+                        self._decorates_method = f.__name__ == x[1].__func__.__name__
+                        if self._decorates_method:
+                            break
+                            
+            #for the first time only check if a transformation function is a method
+            if self._trans_is_method is None:
+                self._trans_is_method = "self" in inspect.getargspec(self._transformation).args
+            
+            current_coverage = self.coverage
+            self._new_hits = [] 
+            
+            #if function is bound then remove "self" from the arguments list
+            if self._decorates_method ^ self._trans_is_method:
+                result = self._transformation(*cb_args[1:]) 
+            else:
+                result = self._transformation(*cb_args)
+                
+            #compare function result using relation function with matching bins
+            for bins in self._hits:
+                if self._relation(result, bins):
+                    self._hits[bins] += 1
+                    self._new_hits.append(bins)
+                    #check bins callbacks
+                    if bins in self._bins_callbacks:
+                        self._bins_callbacks[bins]()
+                    #if injective function, continue through all bins
+                    if not self._injection:
+                        break 
+            
+            #notify parent about new coverage level
+            self._parent._update_coverage(self.coverage-current_coverage)
+            
+            #check threshold callbacks
+            for ii in self._threshold_callbacks:
+                if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
+                    self._threshold_callbacks[ii]() 
+                
+            return f(*cb_args, **cb_kwargs)
+        return _wrapped_function
+    
+    @property
+    def size(self):
+        return self._size
+        
+    @property
+    def coverage(self):
+        coverage = self._size
+        for ii in self._hits:
+            if self._hits[ii] < self._at_least:
+                coverage -= self._weight
+        return coverage
+        
+    @property
+    def detailed_coverage(self):
+        return self._hits
+        
+        
+class CoverCross(CoverItem):
+    """
+    Class used to create coverage crosses as decorators. It matches tuples cross-bins which are
+    Cartesian products of bins defined in CoverPoints (items).
+    Syntax:
+    @coverage.CoverCross(name, items, ign_bins, weight, at_least, ign_rel)
+    Where:
+    name - a CoverCross path and name, defining its position in a coverage trie
+    items - a list of CoverPoints by names, to create a Cartesian product of cross-bins
+    ign_bins - (optional) a list of bins to be ignored
+    weight - (optional) a CoverCross weight (by default 1)
+    at_least - (optional) defines number of hits per bin to be considered as covered (by default 1)
+    ign_rel - (optional) defines a relation which applies to the ign_bins list (by default equality operator)
+    
+    Example:
+    @coverage.CoverPoint(name = "top.parent.coverpoint1", f = lambda x, y: x, bins = range(1,5))
+    @coverage.CoverPoint(name = "top.parent.coverpoint2", f = lambda x, y: y, bins = range(1,5))
+    @coverage.CoverCross(
+      name = "top.parent.covercross", 
+      items = ["top.parent.coverpoint1", "top.parent.coverpoint2"],
+      ign_bins = [(1,1), (5,5)],
+    )
+    def decorated_fun(self, arg_a, arg_b):
+      ...
+    Bin from the bins list [(1,2),(1,3)...(5,4)] will be matched when a tuple (x=arg_a, y=arg_b) 
+    sampled at decorated_fun call.
+    """
+    
+    #conditional Object creation, only if name not already registered
+    def __new__(cls, name, items = [], ign_bins = [], weight=1, at_least=1, ign_rel = None):
+        if name in coverage_db:
+            return coverage_db[name]
+        else:
+            return super(CoverCross, cls).__new__(CoverCross)
+
+    def __init__(self, name, items = [], ign_bins = [], weight=1, at_least=1, ign_rel = None):
+        if not name in coverage_db:
+            CoverItem.__init__(self, name)
+            self._weight = weight
+            self._at_least = at_least
+            #equality operator is the defult ignore bins matching relation
+            self._relation = ign_rel if ign_rel is not None else operator.eq
+            self._items = items
+            
+            bins_lists = []
+            for cp_names in self._items:
+                bins_lists.append(coverage_db[cp_names].detailed_coverage.keys())
+                
+            #a map of cross-bins, key is a tuple of bins Cartesian product
+            self._hits = dict.fromkeys(itertools.product(*bins_lists), 0) 
+            
+            #remove ignore bins from _hits map if relation is true
+            for x_bins in self._hits.keys():
+                for ignore_bins in ign_bins:
+                    remove = True
+                    for ii in range(0,len(x_bins)):
+                        if ignore_bins[ii] is not None:
+                            if not self._relation(ignore_bins[ii], x_bins[ii]):
+                                remove = False
+                    if remove:
+                        del self._hits[x_bins]
+                        
+            self._size = self._weight*len(self._hits)            
+            self._parent._update_size(self._size)
+
+    def __call__(self, f):
+        @wraps(f)
+        def _wrapped_function(*cb_args, **cb_kwargs):
+            
+            current_coverage = self.coverage
+            
+            hit_lists = []
+            for cp_name in self._items:
+                hit_lists.append(coverage_db[cp_name]._new_hits)
+                
+            #a list of hit cross-bins, key is a tuple of bins Cartesian product
+            for x_bins_hit in list(itertools.product(*hit_lists)):
+                if x_bins_hit in self._hits:
+                    self._hits[x_bins_hit] += 1
+                    #check bins callbacks
+                    if x_bins_hit in self._bins_callbacks:
+                        self._bins_callbacks[x_bins_hit]()
+            
+            #notify parent about new coverage level
+            self._parent._update_coverage(self.coverage-current_coverage)
+            
+            #check threshold callbacks
+            for ii in self._threshold_callbacks:
+                if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
+                    self._threshold_callbacks[ii]() 
+                
+            return f(*cb_args, **cb_kwargs)
+        return _wrapped_function
+                
+    @property
+    def size(self):
+        return self._size
+        
+    @property
+    def coverage(self):
+        coverage = self._size
+        for ii in self._hits:
+            if self._hits[ii] < self._at_least:
+                coverage -= self._weight
+        return coverage
+        
+    @property
+    def detailed_coverage(self):
+        return self._hits
+
+class CoverCheck(CoverItem):
+    """
+    Class used to create coverage checks as decorators. It is a simplified CoverPoint
+    with defined 2 bins: "PASS" and "FAIL" and f_pass() and f_fail() functions. 
+    Syntax:
+    @coverage.CoverCheck(name, f_fail, f_pass, weight, at_least)    
+    Where:
+    name - a CoverCheck path and name, defining its position in a coverage trie
+    f_fail - a failure function, if returned true, a coverage level is set 0% permanently
+    f_pass - a pass function, if returned true coverage level is set 100% after (at_least) hits
+    weight - (optional) a CoverCheck weight (by default 1)
+    at_least - (optional) defines how many times f_pass needs to be satisfied (by default 1)
+    Example:
+    @coverage.CoverCheck(
+      name = "top.parent.check", 
+      f_fail = lambda x : x == 0, 
+      f_pass = lambda x : x < 5)
+    def decorated_fun(self, arg):
+      ...
+    A CoverCheck is satisfied (100% covered) when sampled arg < 5 and never sampled arg == 0.
+    A CoverCheck is failed (0% covered) when at least once sampled arg == 0.
+      
+    """
+    #conditional Object creation, only if name not already registered
+    def __new__(cls, name, f_fail, f_pass=None, weight=1, at_least=1):
+        if name in coverage_db:
+            return coverage_db[name]
+        else:
+            return super(CoverCheck, cls).__new__(CoverCheck)
+
+    def __init__(self, name, f_fail, f_pass=None, weight=1, at_least=1):
+        if not name in coverage_db:
+            CoverItem.__init__(self, name)
+            self._weight = weight
+            self._at_least = at_least
+            self._f_pass = f_pass
+            self._f_fail = f_fail
+            self._size = weight
+            self._hits = dict.fromkeys(["PASS", "FAIL"], 0)
+            
+            self._decorates_method = None #determines whether decorated a bound method
+            self._f_pass_is_method = None #determines whether pass function is a bound method
+            self._f_fail_is_method = None #determines whether fail function is a bound method
+            self._parent._update_size(self._size)
+
+    def __call__(self, f):
+        @wraps(f)
+        def _wrapped_function(*cb_args, **cb_kwargs):
+                            
+            #if pass function not defined always return True
+            if self._f_pass is None:
+                def dummy_f(*cb_args):
+                    return True
+                self._f_pass = dummy_f
+                            
+            #for the first time only check if decorates method in the class
+            if self._decorates_method is None:
+                self._decorates_method = False
+                for x in inspect.getmembers(cb_args[0]):
+                    if '__func__' in dir(x[1]):
+                        #compare decorated function name with class functions
+                        self._decorates_method = f.__name__ == x[1].__func__.__name__
+                        if self._decorates_method:
+                            break
+                            
+                            
+                            
+            #for the first time only check if a pass/fail function is a method
+            if self._f_pass_is_method is None and self._f_pass:
+                self._f_pass_is_method = "self" in inspect.getargspec(self._f_pass).args
+            if self._f_fail_is_method is None:
+                self._f_fail_is_method = "self" in inspect.getargspec(self._f_fail).args
+                
+            current_coverage = self.coverage
+                
+            #may be False (failed), True (passed) or None (undetermined)
+            passed = None
+            
+            #if function is bound then remove "self" from the arguments list
+            if self._decorates_method ^ self._f_pass_is_method:
+                passed = True if self._f_pass(*cb_args[1:]) else None
+            else:
+                passed = True if self._f_pass(*cb_args) else None
+                
+            if self._decorates_method ^ self._f_fail_is_method:
+                passed = False if self._f_fail(*cb_args[1:]) else passed
+            else:
+                passed = False if self._f_fail(*cb_args) else passed
+                
+            if passed:
+                self._hits["PASS"] += 1
+            elif not passed:
+                self._hits["FAIL"] += 1
+                    
+            if passed is not None:
+                        
+                #notify parent about new coverage level
+                self._parent._update_coverage(self.coverage-current_coverage)
+                
+                #check threshold callbacks
+                for ii in self._threshold_callbacks:
+                    if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
+                        self._threshold_callbacks[ii]() 
+                                         
+                #check bins callbacks
+                if "PASS" in self._bins_callbacks and passed:
+                    self._bins_callbacks["PASS"]() 
+                elif "FAIL" in self._bins_callbacks and not passed:
+                    self._bins_callbacks["FAIL"]() 
+                            
+                
+            return f(*cb_args, **cb_kwargs)
+        return _wrapped_function
+                
+    @property
+    def size(self):
+        return self._size
+        
+    @property
+    def coverage(self):
+        coverage = 0
+        if self._hits["FAIL"] == 0 and self._hits["PASS"] > self._at_least:
+            coverage = self._weight 
+        return coverage
+        
+    @property
+    def detailed_coverage(self):
+        return self._hits
diff --git a/cocotb/crv.py b/cocotb/crv.py
new file mode 100644
index 00000000..68822410
--- /dev/null
+++ b/cocotb/crv.py
@@ -0,0 +1,64 @@
+
+"""
+Contrained-random verification features.
+
+Classes:
+Randomized - base class for objects intended to have random variables
+"""
+
+import random
+import constraint
+import inspect
+import copy
+
+class Randomized(object):
+
+    def __init__(self):
+        self._problem = constraint.Problem()
+        self._randVariables = {}
+    
+    def addRand(self, var, domain):
+        self._randVariables[var] = domain #add variable to the map
+        self._problem.addVariable(var, domain)
+    
+    def addConstraint(self, constraint):
+        variables = inspect.getargspec(constraint).args
+        self._problem.addConstraint(constraint, variables)
+        
+    def pre_randomize(self):
+        pass
+    
+    def post_randomize(self):
+        pass
+        
+    def randomize(self, *constraints):
+        """
+        Randomizes a final class using predefined constraints + optional
+        constraints given in an argument.
+        """
+        problem = copy.copy(self._problem)            
+        self.pre_randomize()
+        for cstr in constraints:
+            variables = inspect.getargspec(cstr).args
+            problem.addConstraint(cstr, variables)
+        solutions = problem.getSolutions()
+        solution = solutions[random.randint(0,len(solutions)-1)]
+        for var in self._randVariables:
+            setattr(self, var, solution[var]) 
+        self.post_randomize()
+        
+    def randomize_with(self, *constraints):
+        """
+        Randomizes a final class using only constraints given in an argument.
+        """
+        problem = constraint.Problem() 
+        for var in self._randVariables:
+            problem.addVariable(var, self._randVariables[var])    
+        for cstr in constraints:
+            variables = inspect.getargspec(cstr).args
+            problem.addConstraint(cstr, variables)
+        solutions = problem.getSolutions()
+        solution = solutions[random.randint(0,len(solutions)-1)]
+        for var in self._randVariables:
+            setattr(self, var, solution[var]) 
+    

From 1bde588759abff2abb4323cba7b84d0f0c1773c2 Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sat, 5 Mar 2016 19:20:35 +0100
Subject: [PATCH 02/13] added coverage and randomization example to
 test_mean.py

---
 examples/mean/tests/test_mean.py | 107 +++++++++++++++++++++++++++++++++++++++
 1 file changed, 107 insertions(+)

diff --git a/examples/mean/tests/test_mean.py b/examples/mean/tests/test_mean.py
index b333b036..5049a7b7 100644
--- a/examples/mean/tests/test_mean.py
+++ b/examples/mean/tests/test_mean.py
@@ -5,9 +5,14 @@
 from cocotb.triggers import Timer, RisingEdge, ReadOnly
 from cocotb.result import TestFailure
 from cocotb.monitors import BusMonitor
+from cocotb.drivers import BusDriver
 from cocotb.scoreboard import Scoreboard
+from cocotb.crv import Randomized
+
+import cocotb.coverage
 
 import random
+import itertools
 
 clock_period = 100
 
@@ -26,9 +31,70 @@ def _monitor_recv(self):
             yield RisingEdge(self.clock)
             yield ReadOnly()
             if self.bus.valid.value:
+                print (self.bus.data.value)
                 self._recv(int(self.bus.data.value))
+                
+class StreamTransaction(Randomized):
+    """
+    randomized transaction
+    """
+    def __init__(self, bus_width, data_width):
+        Randomized.__init__(self)
+        self.bus_width = bus_width
+        self.data_width = data_width
+        self.data = ()
+                
+        list_data = range(0, 2**data_width)
+                
+        combinations = list(itertools.product(list_data, repeat=bus_width))
+        
+        self.addRand("data", combinations) 
+            
+    def mean_value(self):
+        return sum(self.data) // self.bus_width
+        
+                
+class StreamBusDriver(BusDriver):
+    """
+    streaming bus monitor
+    """
+    _signals = ["valid", "data"]
+    
+    def __init__(self, entity, name, clock):
+        BusDriver.__init__(self, entity, name, clock)
 
 
+    @cocotb.coroutine
+    def send(self, transaction):
+                                
+        i = 0
+        for x in transaction.data:
+            self.bus.data[i] = x
+            i = i + 1
+        self.bus.valid <= 1
+       
+        yield RisingEdge(self.clock)
+        self.bus.valid <= 1
+        
+        @cocotb.coverage.CoverPoint("top.data1", 
+            f = lambda transaction : transaction.data[0], 
+            bins = range(0, 2**transaction.data_width)
+            )
+        @cocotb.coverage.CoverPoint("top.dataN", 
+            f = lambda transaction : transaction.data[transaction.bus_width-1], 
+            bins = range(0, 2**transaction.data_width)
+        )
+        def sample_coverage(transaction):
+            """
+            We need this sampling function inside the class function, as
+            self needs to exist (required for bins creation). If not needed,
+            just "send" could be decorated.
+            """
+            pass
+            
+        sample_coverage(transaction)
+        
+
 @cocotb.coroutine
 def clock_gen(signal, period=10000):
     while True:
@@ -124,3 +190,44 @@ def mean_randomised_test(dut):
         exp_out.append(nums_mean)
         yield RisingEdge(dut.clk)
         dut.i_valid <= 0
+        
+@cocotb.test()
+def mean_mdv_test(dut):
+    """ Test using functional coverage measurements and 
+        Constrained-Random mechanisms. Generates random transactions
+        until coverage defined in Driver reaches 90% """
+
+
+    dut_out = StreamBusMonitor(dut, "o", dut.clk)
+    dut_in = StreamBusDriver(dut, "i", dut.clk)
+
+    exp_out = []
+    scoreboard = Scoreboard(dut)
+    scoreboard.add_interface(dut_out, exp_out)
+
+    data_width = int(dut.DATA_WIDTH.value)
+    bus_width = int(dut.BUS_WIDTH.value)
+    dut.log.info('Detected DATA_WIDTH = %d, BUS_WIDTH = %d' %
+                 (data_width, bus_width))
+
+    cocotb.fork(clock_gen(dut.clk, period=clock_period))
+
+    dut.rst <= 1
+    for i in range(bus_width):
+        dut.i_data[i] = 0
+    dut.i_valid <= 0
+    yield RisingEdge(dut.clk)
+    yield RisingEdge(dut.clk)
+    dut.rst <= 0
+    
+    coverage = 0
+    while coverage < 90:
+        xaction = StreamTransaction(bus_width, data_width)
+        xaction.randomize()
+        print (xaction.data)
+        yield dut_in.send(xaction)
+        exp_out.append(xaction.mean_value())
+        coverage = cocotb.coverage.coverage_db["top"].coverage*100/cocotb.coverage.coverage_db["top"].size
+        
+
+

From f42b871f69c667e41771e86439ab4b4e8e6e280a Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sun, 6 Mar 2016 15:15:21 +0100
Subject: [PATCH 03/13] added disclaimers and costrained randomization example

---
 cocotb/coverage.py               | 29 +++++++++++++++++++++++++++++
 cocotb/crv.py                    | 25 +++++++++++++++++++++++++
 examples/mean/tests/test_mean.py | 39 +++++++++++++++++++++++++++++++--------
 3 files changed, 85 insertions(+), 8 deletions(-)

diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index b0cd7948..d2d7f79d 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -1,4 +1,29 @@
 
+'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met (The BSD 2-Clause 
+License):
+
+1. Redistributions of source code must retain the above copyright notice, 
+this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+this list of conditions and the following disclaimer in the documentation and/or 
+other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
+
 """
 Functional Coverage features.
 Global variable:
@@ -215,6 +240,10 @@ def coverage(self):
     def detailed_coverage(self):
         return self._hits
         
+    @property
+    def new_hits(self):
+        return self._new_hits
+        
         
 class CoverCross(CoverItem):
     """
diff --git a/cocotb/crv.py b/cocotb/crv.py
index 68822410..ba6083b4 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -1,4 +1,29 @@
 
+'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met (The BSD 2-Clause 
+License):
+
+1. Redistributions of source code must retain the above copyright notice, 
+this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+this list of conditions and the following disclaimer in the documentation and/or 
+other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
+
 """
 Contrained-random verification features.
 
diff --git a/examples/mean/tests/test_mean.py b/examples/mean/tests/test_mean.py
index 5049a7b7..4567ca0a 100644
--- a/examples/mean/tests/test_mean.py
+++ b/examples/mean/tests/test_mean.py
@@ -31,7 +31,7 @@ def _monitor_recv(self):
             yield RisingEdge(self.clock)
             yield ReadOnly()
             if self.bus.valid.value:
-                print (self.bus.data.value)
+                print (int(self.bus.data.value))
                 self._recv(int(self.bus.data.value))
                 
 class StreamTransaction(Randomized):
@@ -69,6 +69,7 @@ def send(self, transaction):
                                 
         i = 0
         for x in transaction.data:
+            print ("send %d", x)
             self.bus.data[i] = x
             i = i + 1
         self.bus.valid <= 1
@@ -76,6 +77,8 @@ def send(self, transaction):
         yield RisingEdge(self.clock)
         self.bus.valid <= 1
         
+        #functional coverage - check if all possible data values were
+        #sampled at first and last input
         @cocotb.coverage.CoverPoint("top.data1", 
             f = lambda transaction : transaction.data[0], 
             bins = range(0, 2**transaction.data_width)
@@ -87,8 +90,8 @@ def send(self, transaction):
         def sample_coverage(transaction):
             """
             We need this sampling function inside the class function, as
-            self needs to exist (required for bins creation). If not needed,
-            just "send" could be decorated.
+            transaction object needs to exist (required for bins creation). 
+            If not needed, just "send" could be decorated.
             """
             pass
             
@@ -182,6 +185,7 @@ def mean_randomised_test(dut):
         nums = []
         for i in range(bus_width):
             x = random.randint(0, 2**data_width - 1)
+            print ("send %d", x)
             dut.i_data[i] = x
             nums.append(x)
         dut.i_valid <= 1
@@ -195,7 +199,7 @@ def mean_randomised_test(dut):
 def mean_mdv_test(dut):
     """ Test using functional coverage measurements and 
         Constrained-Random mechanisms. Generates random transactions
-        until coverage defined in Driver reaches 90% """
+        until coverage defined in Driver reaches 99% """
 
 
     dut_out = StreamBusMonitor(dut, "o", dut.clk)
@@ -220,11 +224,30 @@ def mean_mdv_test(dut):
     yield RisingEdge(dut.clk)
     dut.rst <= 0
     
+    coverage1_hits = []
+    coverageN_hits = []
+    
+    #define a constraint function, which prevents from picking already covered data
+    def data_constraint(data):
+        return (not data[0] in coverage1_hits) & (not data[bus_width-1] in coverageN_hits)
+    
     coverage = 0
-    while coverage < 90:
-        xaction = StreamTransaction(bus_width, data_width)
-        xaction.randomize()
-        print (xaction.data)
+    xaction = StreamTransaction(bus_width, data_width)
+    while coverage < 99:
+        
+        #randomize without constraint
+        #xaction.randomize() 
+        
+        #randomize with constraint
+        if not "top.data1" in cocotb.coverage.coverage_db:
+            xaction.randomize()
+        else:
+            coverage1_new_bins = cocotb.coverage.coverage_db["top.data1"].new_hits
+            coverageN_new_bins = cocotb.coverage.coverage_db["top.dataN"].new_hits
+            coverage1_hits.extend(coverage1_new_bins)
+            coverageN_hits.extend(coverageN_new_bins)
+            xaction.randomize_with(data_constraint)
+            
         yield dut_in.send(xaction)
         exp_out.append(xaction.mean_value())
         coverage = cocotb.coverage.coverage_db["top"].coverage*100/cocotb.coverage.coverage_db["top"].size

From 77ae0f99287ebca5d484a4567eb0813ff50a8a29 Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sun, 6 Mar 2016 15:35:39 +0100
Subject: [PATCH 04/13] removed printfs, fixed mean.vhd module

---
 examples/mean/hdl/mean.vhd       | 4 ++--
 examples/mean/tests/test_mean.py | 4 +---
 2 files changed, 3 insertions(+), 5 deletions(-)

diff --git a/examples/mean/hdl/mean.vhd b/examples/mean/hdl/mean.vhd
index 5ff90a6a..52659864 100644
--- a/examples/mean/hdl/mean.vhd
+++ b/examples/mean/hdl/mean.vhd
@@ -23,8 +23,8 @@ end mean;
 
 architecture RTL of mean is
 
-  signal s_sum : unsigned(DATA_WIDTH + clog2(BUS_WIDTH-1)-1 downto 0) := (others => '0');  -- introduce bug
---  signal s_sum : unsigned(DATA_WIDTH + clog2(BUS_WIDTH)-1 downto 0) := (others => '0');
+  --signal s_sum : unsigned(DATA_WIDTH + clog2(BUS_WIDTH-1)-1 downto 0) := (others => '0');  -- introduce bug
+  signal s_sum : unsigned(DATA_WIDTH + clog2(BUS_WIDTH)-1 downto 0) := (others => '0');
   signal s_valid : std_logic := '0';
   
 begin
diff --git a/examples/mean/tests/test_mean.py b/examples/mean/tests/test_mean.py
index 4567ca0a..250f3552 100644
--- a/examples/mean/tests/test_mean.py
+++ b/examples/mean/tests/test_mean.py
@@ -31,7 +31,6 @@ def _monitor_recv(self):
             yield RisingEdge(self.clock)
             yield ReadOnly()
             if self.bus.valid.value:
-                print (int(self.bus.data.value))
                 self._recv(int(self.bus.data.value))
                 
 class StreamTransaction(Randomized):
@@ -69,7 +68,6 @@ def send(self, transaction):
                                 
         i = 0
         for x in transaction.data:
-            print ("send %d", x)
             self.bus.data[i] = x
             i = i + 1
         self.bus.valid <= 1
@@ -185,7 +183,6 @@ def mean_randomised_test(dut):
         nums = []
         for i in range(bus_width):
             x = random.randint(0, 2**data_width - 1)
-            print ("send %d", x)
             dut.i_data[i] = x
             nums.append(x)
         dut.i_valid <= 1
@@ -251,6 +248,7 @@ def data_constraint(data):
         yield dut_in.send(xaction)
         exp_out.append(xaction.mean_value())
         coverage = cocotb.coverage.coverage_db["top"].coverage*100/cocotb.coverage.coverage_db["top"].size
+        dut.log.info("Current Coverage = %d %%", coverage)
         
 
 

From 74aff6332a34b4a34b977f1404cb172dbf8d497a Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sun, 21 Aug 2016 19:14:08 +0200
Subject: [PATCH 05/13] added distributions in CRV mechanisms

---
 cocotb/crv.py | 31 +++++++++++++++++++++++++++----
 1 file changed, 27 insertions(+), 4 deletions(-)

diff --git a/cocotb/crv.py b/cocotb/crv.py
index ba6083b4..9a57343b 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -41,15 +41,20 @@ class Randomized(object):
     def __init__(self):
         self._problem = constraint.Problem()
         self._randVariables = {}
+        self._distributions = {}
     
     def addRand(self, var, domain):
         self._randVariables[var] = domain #add variable to the map
         self._problem.addVariable(var, domain)
+        self._distributions[var] = lambda _: 1 #uniform distribution
     
     def addConstraint(self, constraint):
         variables = inspect.getargspec(constraint).args
         self._problem.addConstraint(constraint, variables)
         
+    def addDistribution(self, var, distribution):
+        self._distributions[var] = distribution
+        
     def pre_randomize(self):
         pass
     
@@ -66,8 +71,7 @@ def randomize(self, *constraints):
         for cstr in constraints:
             variables = inspect.getargspec(cstr).args
             problem.addConstraint(cstr, variables)
-        solutions = problem.getSolutions()
-        solution = solutions[random.randint(0,len(solutions)-1)]
+        solution = self.resolve(problem)
         for var in self._randVariables:
             setattr(self, var, solution[var]) 
         self.post_randomize()
@@ -82,8 +86,27 @@ def randomize_with(self, *constraints):
         for cstr in constraints:
             variables = inspect.getargspec(cstr).args
             problem.addConstraint(cstr, variables)
-        solutions = problem.getSolutions()
-        solution = solutions[random.randint(0,len(solutions)-1)]
+        solution = self.resolve(problem)
         for var in self._randVariables:
             setattr(self, var, solution[var]) 
+            
+    def resolve(self, problem):
+        solutions = problem.getSolutions()
+        solution_weights = []
+        for sol in solutions: #take single solution
+            weight = 1.0
+            for var in self._randVariables:
+                weight = weight*self._distributions[var](sol[var]) #calculate weight of total solution
+            solution_weights.append(weight)
+        #numpy should be used instead...
+        #solution = numpy.random.choice(solutions,size=1,p=solution_weights) #pick weighted random
+        #if numpy not available
+        min_weight = min(weight for weight in solution_weights if weight > 0)
+        solution_weights = map (lambda x: int(x*(1/min_weight)), solution_weights) #convert weights to int
+        weighted_solutions = []
+        for x in range(len(solutions)):
+            weighted_solutions = weighted_solutions + \
+              [solutions[x] for _ in range(solution_weights[x])] #multiply each solution in list accordingly
+        return random.choice(weighted_solutions)
+        
     

From 4c5fa591e203522e0e7d0bf3971c6e0b09e475df Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Fri, 16 Sep 2016 15:18:53 +0200
Subject: [PATCH 06/13] finished implementation of the CRV features, added
 unittests

---
 cocotb/coverage.py               |  22 +++
 cocotb/crv.py                    | 341 +++++++++++++++++++++++++++++++++------
 cocotb/crv_unittest.py           | 171 ++++++++++++++++++++
 examples/mean/tests/test_mean.py |   8 +-
 4 files changed, 489 insertions(+), 53 deletions(-)
 create mode 100644 cocotb/crv_unittest.py

diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index d2d7f79d..a37b3da6 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -34,6 +34,9 @@
 CoverPoint - a cover point with bins
 CoverCross - a cover cross with references to CoverPoints
 CoverCheck - a cover point which checks only a pass/fail condition
+
+Functions:
+report_coverage(logger, bins) - prints coverage
 """
 
 from functools import wraps
@@ -483,3 +486,22 @@ def coverage(self):
     @property
     def detailed_coverage(self):
         return self._hits
+
+def report_coverage(logger, bins=False):
+    """Prints sorted coverage with optional bins details"""
+    sorted_cov = sorted(coverage_db, key=str.lower)
+    for ii in sorted_cov:
+        logger ("   "*ii.count('.') + "%s : %s, coverage=%d, size=%d ", 
+          ii, 
+          coverage_db[ii], 
+          coverage_db[ii].coverage, 
+          coverage_db[ii].size
+        )
+        if (type(coverage_db[ii]) is not CoverItem) & (bins):
+            for jj in coverage_db[ii].detailed_coverage:
+                logger ("   "*ii.count('.') + "   BIN %s : %s", 
+                  jj, 
+                  coverage_db[ii].detailed_coverage[jj]
+                )
+
+
diff --git a/cocotb/crv.py b/cocotb/crv.py
index 9a57343b..17eb5636 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -35,25 +35,107 @@
 import constraint
 import inspect
 import copy
+import itertools
 
 class Randomized(object):
 
     def __init__(self):
-        self._problem = constraint.Problem()
-        self._randVariables = {}
-        self._distributions = {}
+        #all random variables, map NAME -> DOMAIN
+        self._randVariables = {} 
+        #all simple constraints: functions of single random variable and optional non-random variables
+        #map VARIABLE NAME -> FUNCTION
+        self._simpleConstraints = {} 
+        #all implicit constraints: functions that requires to be resolved by a Solver
+        #map TUPLE OF VARIABLE NAMES -> FUNCTION
+        self._implConstraints = {} 
+        #all implicit distributions: functions that involve implicit random variables and single 
+        #unconstrained variable
+        #map TUPLE OF VARIABLE NAMES -> FUNCTION
+        self._implDistributions = {} 
+        #all simple distributions: functions of unconstrained random variables and non-random variables
+        #map VARIABLE NAME -> FUNCTION
+        self._simpleDistributions = {} 
     
-    def addRand(self, var, domain):
-        self._randVariables[var] = domain #add variable to the map
-        self._problem.addVariable(var, domain)
-        self._distributions[var] = lambda _: 1 #uniform distribution
-    
-    def addConstraint(self, constraint):
-        variables = inspect.getargspec(constraint).args
-        self._problem.addConstraint(constraint, variables)
+    def addRand(self, var, domain=None):
+        assert (not (self._simpleConstraints or self._implConstraints or self._implDistributions or
+             self._simpleDistributions)), "All random variable must be defined before adding a costraint"
+             
+        if not domain:
+            domain = range(65535) #16 bit unsigned int
+                 
+        self._randVariables[var] = domain #add a variable to the map
+
+    def addConstraint(self, cstr):
         
-    def addDistribution(self, var, distribution):
-        self._distributions[var] = distribution
+        if isinstance(cstr, constraint.Constraint):
+            #could be a Constraint object...
+            pass
+        else:
+            variables = inspect.getargspec(cstr).args
+            assert (variables == sorted(variables)), "Variables of constraint function must be in alphabetic order"
+            
+            #determine the function type... rather unpythonic but necessary for distinction between 
+            #a constraint and a distribution
+            callargs = []
+            rand_variables = []
+            for var in variables:
+                if var in self._randVariables:
+                    rand_variables.append(var)
+                    callargs.append(random.choice(self._randVariables[var]))
+                else:
+                    callargs.append(getattr(self, var))
+                
+            ret = cstr(*callargs)
+            
+            def _addToMap(_key, _map):
+                overwriting = None
+                if _key in _map:
+                    overwriting = _map[_key]
+                _map[_key] = cstr
+                return overwriting
+            
+            if type(ret) == bool:
+                #this is a constraint  
+                if (len(rand_variables) == 1):
+                    overwriting = _addToMap(rand_variables[0], self._simpleConstraints)
+                else:
+                    overwriting = _addToMap(tuple(rand_variables), self._implConstraints)
+            else:
+                #this is a distribution
+                if (len(rand_variables) == 1):
+                    overwriting = _addToMap(rand_variables[0], self._simpleDistributions)
+                else:
+                    overwriting = _addToMap(tuple(rand_variables), self._implDistributions)
+
+            #print "adding " + inspect.getsource(cstr)
+            return overwriting
+                    
+    def delConstraint(self, cstr):
+        
+        if isinstance(cstr, constraint.Constraint):
+            #could be a Constraint object...
+            pass
+        else:
+            variables = inspect.getargspec(cstr).args
+            
+            rand_variables = [var for var in variables if var in self._randVariables]
+            
+            if (len(rand_variables) == 1):
+                if rand_variables[0] in self._simpleConstraints:
+                    del self._simpleConstraints[rand_variables[0]]
+                elif rand_variables[0] in self._simpleDistributions:
+                    del self._simpleDistributions[rand_variables[0]]
+                else:
+                    assert(0), "Could not delete a constraint!"
+            else:
+                if tuple(rand_variables) in self._implConstraints:
+                    del self._implConstraints[tuple(rand_variables)]
+                elif tuple(rand_variables) in self._simpleDistributions:
+                    del self._implDistributions[tuple(rand_variables)]
+                else:
+                    assert(0), "Could not delete a constraint!"
+            
+            #print "removing " + inspect.getsource(cstr) 
         
     def pre_randomize(self):
         pass
@@ -63,50 +145,211 @@ def post_randomize(self):
         
     def randomize(self, *constraints):
         """
-        Randomizes a final class using predefined constraints + optional
-        constraints given in an argument.
-        """
-        problem = copy.copy(self._problem)            
+        Randomizes a final class using only predefined constraints.
+        """        
         self.pre_randomize()
-        for cstr in constraints:
-            variables = inspect.getargspec(cstr).args
-            problem.addConstraint(cstr, variables)
-        solution = self.resolve(problem)
-        for var in self._randVariables:
-            setattr(self, var, solution[var]) 
+        solution = self._resolve()
         self.post_randomize()
         
+        self._update_variables(solution)
+        
     def randomize_with(self, *constraints):
         """
-        Randomizes a final class using only constraints given in an argument.
-        """
-        problem = constraint.Problem() 
-        for var in self._randVariables:
-            problem.addVariable(var, self._randVariables[var])    
+        Randomizes a final class using additional constraints given in an argument.
+        """                   
+        
+        overwritten_constrains = []
+        
+        #add new constraints
         for cstr in constraints:
-            variables = inspect.getargspec(cstr).args
-            problem.addConstraint(cstr, variables)
-        solution = self.resolve(problem)
-        for var in self._randVariables:
-            setattr(self, var, solution[var]) 
+            overwritten = self.addConstraint(cstr)
+            if overwritten:
+                overwritten_constrains.append(overwritten)
+        
+        self.pre_randomize()
+        solution = self._resolve()
+        self.post_randomize()
+        
+        self._update_variables(solution)
+        
+        #remove new constraints
+        for cstr in constraints:
+            self.delConstraint(cstr)
+        
+        #add back overwritten constraints
+        for cstr in overwritten_constrains:
+            self.addConstraint(cstr)
+
             
-    def resolve(self, problem):
+    def _resolve(self):
+                
+        #step 1: determine search space by applying simple constraints to the random variables
+        
+        randVariables = dict(self._randVariables) #we need a copy, as we will be updating domains
+        
+        for rvar in randVariables:
+            domain = randVariables[rvar]
+            new_domain = []
+            if rvar in self._simpleConstraints:
+                f_cstr = self._simpleConstraints[rvar] #a simple constratint function to be applied
+                #check if we have non-random vars in cstr...
+                f_c_args = inspect.getargspec(f_cstr).args #arguments of the constraint function
+                for ii in domain:
+                    f_cstr_callvals = []
+                    for f_c_arg in f_c_args:
+                        if (f_c_arg == rvar):
+                            f_cstr_callvals.append(ii)
+                        else:
+                            f_cstr_callvals.append(getattr(self, f_c_arg))
+                    #call simple constraint for each domain element        
+                    if f_cstr(*f_cstr_callvals):
+                        new_domain.append(ii)
+                randVariables[rvar] = new_domain #update the domain with the constrained one
+            
+        #step 2: resolve implicit constraints using external solver
+                
+        #we use external hard constraint solver here - file constraint.py
+        problem = constraint.Problem()
+        
+        constrainedVars = [] #all random variables for the solver
+        
+        for rvars in self._implConstraints:
+            #add all random variables
+            for rvar in rvars:
+                if not rvar in constrainedVars:
+                    problem.addVariable(rvar, randVariables[rvar])
+                    constrainedVars.append(rvar)
+            #add constraint
+            problem.addConstraint(self._implConstraints[rvars],rvars)
+            
+        #solve problem
         solutions = problem.getSolutions()
-        solution_weights = []
-        for sol in solutions: #take single solution
+        
+        #step 3: calculate implicit ditributions for all random variables except simple distributions
+        
+        distrVars = [] #all variables that have defined distribution functions
+        dsolutions = [] #soltuions with applied distribution weights - list of maps VARIABLE -> VALUE
+        
+        for dvars in self._implDistributions:
+            #add all variables that have defined distribution functions
+            for dvar in dvars:
+                if dvar not in distrVars:
+                    distrVars.append(dvar)
+                    
+        #all variables that have defined distributions but uncostrained
+        ducVars = [var for var in distrVars if var not in constrainedVars]
+                     
+        #list of domains of random uncostrained variables
+        ducDomains = [randVariables[var] for var in ducVars]
+        
+        #Cartesian product of above
+        ducSolutions = list(itertools.product(*ducDomains))
+        
+        #merge solutions: constrained ones and all possible distribtion values
+        for sol in solutions: 
+            for ducsol in ducSolutions:
+                dsol = dict(sol) 
+                jj = 0
+                for var in ducVars:
+                    dsol[var] = ducsol[jj]
+                    jj += 1
+                dsolutions.append(dsol)
+                
+        dsolution_weights = []
+        dsolutions_reduced = []
+        
+        for dsol in dsolutions: #take each solution
             weight = 1.0
-            for var in self._randVariables:
-                weight = weight*self._distributions[var](sol[var]) #calculate weight of total solution
-            solution_weights.append(weight)
-        #numpy should be used instead...
-        #solution = numpy.random.choice(solutions,size=1,p=solution_weights) #pick weighted random
-        #if numpy not available
-        min_weight = min(weight for weight in solution_weights if weight > 0)
-        solution_weights = map (lambda x: int(x*(1/min_weight)), solution_weights) #convert weights to int
-        weighted_solutions = []
-        for x in range(len(solutions)):
-            weighted_solutions = weighted_solutions + \
-              [solutions[x] for _ in range(solution_weights[x])] #multiply each solution in list accordingly
-        return random.choice(weighted_solutions)
+            #for all defined implicit distributions
+            for dstr in self._implDistributions:
+                f_idstr = self._implDistributions[dstr]
+                f_id_args = inspect.getargspec(f_idstr).args 
+                #all variables in solution we need to calculate weight
+                f_id_callvals = []
+                for f_id_arg in f_id_args: #for each variable name
+                    if f_id_arg in dsol: #if exists in solution
+                        f_id_callvals.append(dsol[f_id_arg]) 
+                    else: #get as non-random variable
+                        f_id_callvals.append(getattr(self, f_id_arg)) 
+                #update weight of the solution - call dstribution function
+                weight = weight*f_idstr(*f_id_callvals) 
+            #do the same for simple distributions
+            for dstr in self._simpleDistributions:
+                #but only if variable is already in the solution
+                #if it is not, it will be calculated in step 4
+                if dstr in sol: 
+                    f_sdstr = self._simpleDistributions[dstr]
+                    f_sd_args = inspect.getargspec(f_sdstr).args 
+                    #all variables in solution we need to calculate weight
+                    f_sd_callvals = []
+                    for f_sd_arg in f_sd_args: #for each variable name
+                        if f_sd_arg in dsol: #if exists in solution
+                            f_sd_callvals.append(dsol[f_sd_arg]) 
+                        else: #get as non-random variable
+                            f_sd_callvals.append(getattr(self, f_sd_arg)) 
+                    #update weight of the solution - call dstribution function
+                    weight = weight*f_sdstr(*f_sd_callvals) 
+            if (weight > 0.0):
+                dsolution_weights.append(weight)
+                dsolutions_reduced.append(dsol) #remove solutions with weight = 0
+                        
+        solution_choice = self._weighted_choice(dsolutions_reduced, dsolution_weights)
+        solution = solution_choice if solution_choice is not None else {}
+        
+        #step 4: calculate simple ditributions for remaining random variables
+        for dvar in randVariables:
+            if not dvar in solution: #must be already unresolved variable
+                domain = randVariables[dvar]
+                weights = []
+                if dvar in self._simpleDistributions:
+                    f_dstr = self._simpleDistributions[dvar] #a simple distribution to be applied
+                    #check if we have non-random vars in dstr...
+                    f_d_args = inspect.getargspec(f_dstr).args 
+                    f_d_callvals = [] #list of lists of values for function call
+                    for i in domain:
+                        f_d_callval = []
+                        for f_d_arg in f_d_args:
+                            if (f_d_arg == dvar):
+                                f_d_callval.append(i)
+                            else:
+                                f_d_callval.append(getattr(self, f_d_arg))
+                        f_d_callvals.append(f_d_callval)
+                    #call distribution function for each domain element to get the weight
+                    weights = [f_dstr(*f_d_callvals_i) for f_d_callvals_i in f_d_callvals] 
+                    new_solution = self._weighted_choice(domain, weights)
+                    if new_solution is not None:
+                        solution[dvar] = new_solution #append chosen value to the solution 
+                else:
+                    #random variable has no defined distribution function - call simple random.choice
+                    solution[dvar] = random.choice(domain) 
+        
+        return solution
+        
+    def _weighted_choice(self, solutions, weights):
+        try:
+            import numpy
+            return numpy.random.choice(solutions,size=1,p=weights) #pick weighted random
+        except:
+            #if numpy not available
+            non_zero_weights = [x for x in weights if x > 0]
+            
+            if not non_zero_weights:
+                return None
+            
+            min_weight = min(non_zero_weights)
+            
+            weighted_solutions = []
+            
+            for x in range(len(solutions)):
+                #insert each solution to the list multiple times 
+                weighted_solutions.extend([solutions[x] for _ in range(int(weights[x]*(1.0/min_weight)))])
+              
+            return random.choice(weighted_solutions)
+        
+    def _update_variables(self, solution):
+        #update class members
+        for var in self._randVariables:
+            if var in solution:
+                setattr(self, var, solution[var])             
         
     
diff --git a/cocotb/crv_unittest.py b/cocotb/crv_unittest.py
new file mode 100644
index 00000000..de136b9e
--- /dev/null
+++ b/cocotb/crv_unittest.py
@@ -0,0 +1,171 @@
+
+'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met (The BSD 2-Clause 
+License):
+
+1. Redistributions of source code must retain the above copyright notice, 
+this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+this list of conditions and the following disclaimer in the documentation and/or 
+other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
+
+"""
+Contrained-random verification features.
+
+Classes:
+Randomized - base class for objects intended to have random variables
+"""
+
+import unittest
+import crv
+
+
+class TestCRV(unittest.TestCase):
+    
+    class SimpleRandomized(crv.Randomized):
+        def __init__(self, x, y):
+            crv.Randomized.__init__(self)
+            self.x = 0
+            self.y = 0
+        
+            self.addRand("x", range(0,10))
+            self.addRand("y", range(0,10))
+            
+            self.addConstraint(lambda x, y : x < y)
+
+    def test_simple_0(self):
+        print "Running test_simple_0"
+        results = []
+        
+        for i in range (10):
+            a = self.SimpleRandomized(0,0)
+            a.randomize();
+            self.assertTrue(a.x < a.y)
+        
+    class RandomizedTrasaction(crv.Randomized):
+        def __init__(self, address, data=0, write=False, delay=1):
+            crv.Randomized.__init__(self)
+            self.addr = address
+            self.data = data
+            self.write = write
+            self.delay1 = delay
+            self.delay2 = 0
+            self.delay3 = 0
+        
+            if data is None:
+                self.addRand("data")
+                
+            self.addRand("delay1", range(10))
+            self.addRand("delay2", range(10))
+            self.addRand("delay3", range(10))
+            self.addConstraint(lambda delay1, delay2 : delay1 < delay2)
+            self.addConstraint(lambda delay1, delay2 : 0.9 if (delay2 < 5) else 0.1)
+            self.addConstraint(lambda delay1 : 0.7 if (delay1 < 5) else 0.3)
+            self.addConstraint(lambda addr, delay1 : 0.5*delay1 if (addr == 5) else 1)
+            self.addConstraint(lambda addr, data : data <= 10000 if (addr == 0) else data <= 5000)
+            
+    def test_simple_1(self):
+        print "Running test_simple_1"
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.randomize()
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data <= 10000)
+            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
+            
+    def test_randomize_with(self): 
+        print "Running test_randomize_with"
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.randomize_with(lambda delay1, delay2: delay1 == delay2 - 1)
+            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
+            self.assertTrue((x.delay2 - x.delay1) == 1)
+            self.assertTrue(x.data <= 10000)
+            
+    def test_adding_constraints(self): 
+        print "Running test_adding_constraints"
+            
+        c1 = lambda data, delay1 : 0 if (data < 10) else 1
+        c2 = lambda data, delay3 : 0.5*delay3 if (data < 20) else 2*delay3
+        c3 = lambda data : data < 50
+        
+        for i in range(5):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(c1)
+            x.addConstraint(c2)
+            x.addConstraint(c3)
+            x.randomize()
+            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data < 50) #added such new constraint
+            self.assertTrue(x.data > 10) #added distribution with 0 probability
+            
+    def test_deleting_constraints(self): 
+        print "Running test_deleting_constraints"
+            
+        c3 = lambda data : data < 50
+        
+        for i in range(5):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(c3)
+            x.randomize()
+            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data < 50) 
+            x.delConstraint(c3)
+            x.randomize()
+            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data > 50)
+            
+    class RandomizedDist(crv.Randomized):
+        def __init__(self, limit, n):
+            crv.Randomized.__init__(self)
+            self.x = 0
+            self.y = 0
+            self.z = 0
+            self.n = n
+
+            self.addRand("x", range(limit))
+            self.addRand("y", range(limit))
+            self.addRand("z", range(limit))
+            
+    def test_distributions_1(self): 
+        print "Running test_distributions_1"
+            
+        d1 = lambda x: 20/(x+1)
+        d2 = lambda y: 2*y
+        d3 = lambda n, z: n*z
+        
+        x_gr_y = 0
+        
+        for i in range(1,10):
+            foo = self.RandomizedDist(limit=20*i, n=i-1)
+            foo.addConstraint(d1)
+            foo.addConstraint(d2)
+            foo.addConstraint(d3)
+            foo.randomize()
+            print "x = %d, y = %d, z = %d, n = %d" % (foo.x, foo.y, foo.z, foo.n)
+            x_gr_y = x_gr_y + 1 if (foo.x > foo.y) else x_gr_y - 1
+            if (i==1):
+                self.assertTrue(foo.z==0) #z should not be randomised as has 0 probability for each solution
+        
+        self.assertTrue(x_gr_y < 0) #x should be less than y most of the time due to decreasing distribution
+
+if __name__ == '__main__':
+    unittest.main()
diff --git a/examples/mean/tests/test_mean.py b/examples/mean/tests/test_mean.py
index 0951a687..519650a4 100644
--- a/examples/mean/tests/test_mean.py
+++ b/examples/mean/tests/test_mean.py
@@ -196,7 +196,7 @@ def mean_randomised_test(dut):
 def mean_mdv_test(dut):
     """ Test using functional coverage measurements and 
         Constrained-Random mechanisms. Generates random transactions
-        until coverage defined in Driver reaches 99% """
+        until coverage defined in Driver reaches 100% """
 
 
     dut_out = StreamBusMonitor(dut, "o", dut.clk)
@@ -208,7 +208,7 @@ def mean_mdv_test(dut):
 
     data_width = int(dut.DATA_WIDTH.value)
     bus_width = int(dut.BUS_WIDTH.value)
-    dut.log.info('Detected DATA_WIDTH = %d, BUS_WIDTH = %d' %
+    dut._log.info('Detected DATA_WIDTH = %d, BUS_WIDTH = %d' %
                  (data_width, bus_width))
 
     cocotb.fork(clock_gen(dut.clk, period=clock_period))
@@ -230,7 +230,7 @@ def data_constraint(data):
     
     coverage = 0
     xaction = StreamTransaction(bus_width, data_width)
-    while coverage < 99:
+    while coverage < 100:
         
         #randomize without constraint
         #xaction.randomize() 
@@ -248,7 +248,7 @@ def data_constraint(data):
         yield dut_in.send(xaction)
         exp_out.append(xaction.mean_value())
         coverage = cocotb.coverage.coverage_db["top"].coverage*100/cocotb.coverage.coverage_db["top"].size
-        dut.log.info("Current Coverage = %d %%", coverage)
+        dut._log.info("Current Coverage = %d %%", coverage)
         
 
 

From 130c98d2e7dc0495543a072e4a889443f720e794 Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Fri, 16 Sep 2016 19:09:40 +0200
Subject: [PATCH 07/13] added coverageSection and some CRV documentation

---
 cocotb/coverage.py               |  60 +++++++++++++++++-----
 cocotb/crv.py                    | 106 +++++++++++++++++++++++++++++++++++----
 cocotb/crv_unittest.py           |  12 ++---
 examples/mean/tests/test_mean.py |   4 +-
 4 files changed, 153 insertions(+), 29 deletions(-)

diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index a37b3da6..836a31e5 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -26,6 +26,7 @@
 
 """
 Functional Coverage features.
+
 Global variable:
 coverage_db - a coverage prefix tree (map) containing all coverage objects with name string as a key
 
@@ -36,7 +37,10 @@
 CoverCheck - a cover point which checks only a pass/fail condition
 
 Functions:
-report_coverage(logger, bins) - prints coverage
+reportCoverage(logger, bins) - prints coverage
+coverageSection(*CoverItems) - allows for convenient definition of multiple coverage items and combines 
+  them into a single decorator
+
 """
 
 from functools import wraps
@@ -114,13 +118,13 @@ def detailed_coverage(self):
 class CoverPoint(CoverItem):
     """
     Class used to create coverage points as decorators. It matches predefined bins
-    according to the rule rel(f(args), bin) == True 
+    according to the rule rel(xf(args), bin) == True 
     Syntax:
-    @coverage.CoverPoint(name, f, rel, bins, weight, at_least, inj)
+    @coverage.CoverPoint(name, xf, rel, bins, weight, at_least, inj)
     Where:
     name - a CoverPoint path and name, defining its position in a coverage trie
-    f - (optional) transformation function, which transforms arguments of the decorated function (args)
-    rel - (optional) relation function which defines bins matching relation (by default equality operator)
+    xf - (optional) transformation function, which transforms arguments of the decorated function (args)
+    rel - (optional) relation function which defines bins matching relation (by default, equality operator)
     bins - a list of bins objects to be matched
     weight - (optional) a CoverPoint weight (by default 1)
     at_least - (optional) defines number of hits per bin to be considered as covered (by default 1)
@@ -129,7 +133,7 @@ class CoverPoint(CoverItem):
     Example:
     @coverage.CoverPoint(
       name = "top.parent.coverpoint", 
-      f = lambda x : x/2, 
+      xf = lambda x : x/2, 
       rel = lambda x, y : x < y, 
       bins = range(1,5)
     )
@@ -139,16 +143,16 @@ def decorated_fun(self, arg):
     """
     
     #conditional Object creation, only if name not already registered
-    def __new__(cls, name, f=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+    def __new__(cls, name, xf=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
         if name in coverage_db:
             return coverage_db[name]
         else:
             return super(CoverPoint, cls).__new__(CoverPoint)
 
-    def __init__(self, name, f=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+    def __init__(self, name, xf=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
         if not name in coverage_db:
             CoverItem.__init__(self, name)
-            self._transformation = f
+            self._transformation = xf
             #equality operator is the defult bins matching relation
             self._relation = rel if rel is not None else operator.eq
             self._weight = weight
@@ -263,8 +267,8 @@ class CoverCross(CoverItem):
     ign_rel - (optional) defines a relation which applies to the ign_bins list (by default equality operator)
     
     Example:
-    @coverage.CoverPoint(name = "top.parent.coverpoint1", f = lambda x, y: x, bins = range(1,5))
-    @coverage.CoverPoint(name = "top.parent.coverpoint2", f = lambda x, y: y, bins = range(1,5))
+    @coverage.CoverPoint(name = "top.parent.coverpoint1", xf = lambda x, y: x, bins = range(1,5))
+    @coverage.CoverPoint(name = "top.parent.coverpoint2", xf = lambda x, y: y, bins = range(1,5))
     @coverage.CoverCross(
       name = "top.parent.covercross", 
       items = ["top.parent.coverpoint1", "top.parent.coverpoint2"],
@@ -487,7 +491,7 @@ def coverage(self):
     def detailed_coverage(self):
         return self._hits
 
-def report_coverage(logger, bins=False):
+def reportCoverage(logger, bins=False):
     """Prints sorted coverage with optional bins details"""
     sorted_cov = sorted(coverage_db, key=str.lower)
     for ii in sorted_cov:
@@ -504,4 +508,36 @@ def report_coverage(logger, bins=False):
                   coverage_db[ii].detailed_coverage[jj]
                 )
 
+def coverageSection(*coverItems):
+    """
+    Combines multiple coverage items into a single decorator.
+    Example:
+    my_coverage = coverage.coverageSection(
+      coverage.CoverItem("x",...),
+      coverage.CoverItem("y",...),
+      ...
+    )
+    ...
+    @my_coverage()
+    def decorated_fun(self, arg):
+      ...
+    """
+    def nested(*decorators):
+        def decorator(f):
+             for dec in reversed(*decorators):
+                  f = dec(f)
+             return f
+        return decorator
+
+    fNested = nested(coverItems)
+
+    class CoverageSection():
+        def __call__(self, f):
+            @wraps(f)
+            @fNested
+            def _wrapped_function(*cb_args, **cb_kwargs):
+                return f(*cb_args, **cb_kwargs)
+            return _wrapped_function
+
+    return CoverageSection
 
diff --git a/cocotb/crv.py b/cocotb/crv.py
index 17eb5636..e5e92342 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -28,7 +28,7 @@
 Contrained-random verification features.
 
 Classes:
-Randomized - base class for objects intended to have random variables
+Randomized - base class for objects intended to contain random variables
 """
 
 import random
@@ -38,6 +38,37 @@
 import itertools
 
 class Randomized(object):
+    """
+    Base class for randomized types. Final class should contain defined random variables using addRand() 
+    method. Constraints may be added/deleted using add/delConstraint() methods. 
+    Constraint is an arbitrary function and may either return a true/false value (hard constraints) or 
+    a numeric value, which may be interpreted as soft constraints or distribution functions. Constraint 
+    function arguments must match final class attributes (random or not). Constraints may have multiple 
+    random arguments which corresponds to multi-dimensional distributions.
+    Function randomize() performs a randomization for all random variables meeting all defined  constraints. 
+    Function randomize_with() performs a randomization using additional constraint functions given in an 
+    argument.
+    Functions pre/post_randomize() are called before/after randomize and should be overloaded in a final
+    class if necessary. 
+    
+    Example:
+    class FinalRandomized(Randomized)
+      def __init__(self, x):
+        Randomized.__init__(self)
+        self.x = x
+        self.y = 0
+        self.z = 0
+        addRand(y, range(10)) #define y as a random variable taking values from 0 to 9
+        addRand(z, range(5))  #define z as a random variable taking values from 0 to 4
+        addConstraint(lambda x, y: x !=y ) #a hard constraint
+        addConstraint(lambda y, z: y + z ) #multi-dimensional distribution
+        
+    object = FinalRandomized(5)
+    object.randomize_with(lambda z : z > 3) # additional constraint to be applied
+    
+    As generating constrained random objects may involve a lot of computations, it is recommended to limit
+    random variables domains and use pre/post_randomize() methods where possible. 
+    """
 
     def __init__(self):
         #all random variables, map NAME -> DOMAIN
@@ -57,6 +88,19 @@ def __init__(self):
         self._simpleDistributions = {} 
     
     def addRand(self, var, domain=None):
+        """
+        Adds a random variable to the solver. All random variables must be defined before adding any 
+        constraint. Therefore it is highly recommended to do this in an __init__ method. 
+        Syntax:
+        addRand(var, domain)
+        Where:
+        var - a variable name (string) corresponding to the class member variable
+        domain - a list of all allowed values of the variable var
+        
+        Examples:
+        addRand("data", range(1024))
+        addRand("delay", ["small", "medium", "high"])
+        """
         assert (not (self._simpleConstraints or self._implConstraints or self._implDistributions or
              self._simpleDistributions)), "All random variable must be defined before adding a costraint"
              
@@ -66,13 +110,43 @@ def addRand(self, var, domain=None):
         self._randVariables[var] = domain #add a variable to the map
 
     def addConstraint(self, cstr):
+        """
+        Adds a constraint function to the solver. A constraint may return a true/false or a numeric value.
+        Constraint function arguments must be valid class member names (random or not). Arguments must be
+        listed in alphabetical order. Due to calculation complexity, it is recommended to create as few 
+        constraints as possible and implement pre/post randomization methods. 
+        Each constraint is associated with its arguments being random variables, which means for each 
+        random variable combination only one constraint of the true/false type and one numeric may be 
+        defined. The latter will overwrite the existing one. For example, when class has two random 
+        variables (x,y), 6 constraint functions may be defined: boolean an numeric constraints of x, y and
+        a pair (x,y).  
+        Syntax:
+        (ovewritting = )addConstraint(cstr)
+        Where:
+        cstr - a constraint function
+        overwritting - returns an overwritten constraint or None if no overwrite happened (optional)
         
+        Examples:
+        def highdelay_cstr(delay):
+          delay == "high"
+        addConstraint(highdelay_cstr) #hard constraint
+        addConstraint(lambda data : data < 128) #hard constraint
+        #distribution (highest probability density at the boundaries):
+        addConstraint(lambda data : abs(64 - data)) 
+        #hard constraint of multiple variables (some of them may be non-random):
+        addConstraint(lambda x,y,z : x + y + z == 0) 
+        #soft constraint created by applying low probability density for some solutions:
+        addConstraint(lambda delay, size : 0.01 if (size < 5 & delay == "medium") else 1) 
+        #this constraint will overwrite the previously defined (lambda data : data < 128)
+        addConstraint(lambda data : data < 256)
+        """
         if isinstance(cstr, constraint.Constraint):
             #could be a Constraint object...
             pass
         else:
             variables = inspect.getargspec(cstr).args
-            assert (variables == sorted(variables)), "Variables of constraint function must be in alphabetic order"
+            assert (variables == sorted(variables)), \
+              "Variables of constraint function must be in alphabetical order"
             
             #determine the function type... rather unpythonic but necessary for distinction between 
             #a constraint and a distribution
@@ -111,7 +185,16 @@ def _addToMap(_key, _map):
             return overwriting
                     
     def delConstraint(self, cstr):
+        """
+        Deletes a constraint function.
+        Syntax:
+        delConstraint(cstr)
+        Where:
+        cstr - a constraint function
         
+        Example:
+        delConstraint(highdelay_cstr) 
+        """
         if isinstance(cstr, constraint.Constraint):
             #could be a Constraint object...
             pass
@@ -138,26 +221,31 @@ def delConstraint(self, cstr):
             #print "removing " + inspect.getsource(cstr) 
         
     def pre_randomize(self):
+        """
+        A function called before randomize(_with)(). To be overrided in a final class if used. 
+        """
         pass
     
     def post_randomize(self):
+        """
+        A function called after randomize(_with)(). To be overrided in a final class if used. 
+        """
         pass
         
-    def randomize(self, *constraints):
+    def randomize(self):
         """
         Randomizes a final class using only predefined constraints.
         """        
         self.pre_randomize()
         solution = self._resolve()
         self.post_randomize()
-        
         self._update_variables(solution)
         
     def randomize_with(self, *constraints):
         """
-        Randomizes a final class using additional constraints given in an argument.
+        Randomizes a final class using additional constraints given in an argument. Additional constraints
+        may override existing ones.
         """                   
-        
         overwritten_constrains = []
         
         #add new constraints
@@ -169,7 +257,6 @@ def randomize_with(self, *constraints):
         self.pre_randomize()
         solution = self._resolve()
         self.post_randomize()
-        
         self._update_variables(solution)
         
         #remove new constraints
@@ -180,9 +267,10 @@ def randomize_with(self, *constraints):
         for cstr in overwritten_constrains:
             self.addConstraint(cstr)
 
-            
     def _resolve(self):
-                
+        """
+        Resolves constraints. 
+        """   
         #step 1: determine search space by applying simple constraints to the random variables
         
         randVariables = dict(self._randVariables) #we need a copy, as we will be updating domains
diff --git a/cocotb/crv_unittest.py b/cocotb/crv_unittest.py
index de136b9e..f5916d39 100644
--- a/cocotb/crv_unittest.py
+++ b/cocotb/crv_unittest.py
@@ -25,10 +25,7 @@
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
 
 """
-Contrained-random verification features.
-
-Classes:
-Randomized - base class for objects intended to have random variables
+Contrained-random verification features unittest.
 """
 
 import unittest
@@ -42,20 +39,23 @@ def __init__(self, x, y):
             crv.Randomized.__init__(self)
             self.x = 0
             self.y = 0
+            self.size = "small"
         
             self.addRand("x", range(0,10))
             self.addRand("y", range(0,10))
+            self.addRand("size", ["small", "medium", "large"])
             
             self.addConstraint(lambda x, y : x < y)
 
     def test_simple_0(self):
         print "Running test_simple_0"
-        results = []
-        
+        size_hits = []
         for i in range (10):
             a = self.SimpleRandomized(0,0)
             a.randomize();
             self.assertTrue(a.x < a.y)
+            size_hits.append(a.size)
+        self.assertTrue([x in size_hits for x in["small", "medium", "large"]] == [True, True, True])
         
     class RandomizedTrasaction(crv.Randomized):
         def __init__(self, address, data=0, write=False, delay=1):
diff --git a/examples/mean/tests/test_mean.py b/examples/mean/tests/test_mean.py
index 519650a4..7fa9bd58 100644
--- a/examples/mean/tests/test_mean.py
+++ b/examples/mean/tests/test_mean.py
@@ -78,11 +78,11 @@ def send(self, transaction):
         #functional coverage - check if all possible data values were
         #sampled at first and last input
         @cocotb.coverage.CoverPoint("top.data1", 
-            f = lambda transaction : transaction.data[0], 
+            xf = lambda transaction : transaction.data[0], 
             bins = range(0, 2**transaction.data_width)
             )
         @cocotb.coverage.CoverPoint("top.dataN", 
-            f = lambda transaction : transaction.data[transaction.bus_width-1], 
+            xf = lambda transaction : transaction.data[transaction.bus_width-1], 
             bins = range(0, 2**transaction.data_width)
         )
         def sample_coverage(transaction):

From 6f38072316980d4c8f0a2ccd74449e9ffff11bba Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sat, 17 Sep 2016 19:53:49 +0200
Subject: [PATCH 08/13] code improvements for Python3

---
 cocotb/constraint.py   |  32 ++--
 cocotb/coverage.py     | 416 +++++++++++++++++++++++++---------------------
 cocotb/crv.py          | 435 +++++++++++++++++++++++++++----------------------
 cocotb/crv_unittest.py | 394 +++++++++++++++++++++++++-------------------
 4 files changed, 713 insertions(+), 564 deletions(-)

diff --git a/cocotb/constraint.py b/cocotb/constraint.py
index b1cd836b..8f7e7e21 100644
--- a/cocotb/constraint.py
+++ b/cocotb/constraint.py
@@ -134,17 +134,17 @@ def addVariable(self, variable, domain):
         @type  domain: list, tuple, or instance of C{Domain}
         """
         if variable in self._variables:
-            raise ValueError, "Tried to insert duplicated variable %s" % \
-                              repr(variable)
+            raise ValueError("Tried to insert duplicated variable %s" % \
+                              repr(variable))
         if type(domain) in (list, tuple):
             domain = Domain(domain)
         elif isinstance(domain, Domain):
             domain = copy.copy(domain)
         else:
-            raise TypeError, "Domains must be instances of subclasses of "\
-                             "the Domain class"
+            raise TypeError("Domains must be instances of subclasses of "\
+                             "the Domain class")
         if not domain:
-            raise ValueError, "Domain is empty"
+            raise ValueError("Domain is empty")
         self._variables[variable] = domain
 
     def addVariables(self, variables, domain):
@@ -195,8 +195,8 @@ def addConstraint(self, constraint, variables=None):
             if callable(constraint):
                 constraint = FunctionConstraint(constraint)
             else:
-                raise ValueError, "Constraints must be instances of "\
-                                  "subclasses of the Constraint class"
+                raise ValueError("Constraints must be instances of "\
+                                  "subclasses of the Constraint class")
         self._constraints.append((constraint, variables))
 
     def getSolution(self):
@@ -376,8 +376,8 @@ def getSolution(self, domains, constraints, vconstraints):
                              constraints affecting the given variables.
         @type  vconstraints: dict
         """
-        raise NotImplementedError, \
-              "%s is an abstract class" % self.__class__.__name__
+        raise NotImplementedError( \
+              "%s is an abstract class" % self.__class__.__name__)
 
     def getSolutions(self, domains, constraints, vconstraints):
         """
@@ -391,8 +391,8 @@ def getSolutions(self, domains, constraints, vconstraints):
                              constraints affecting the given variables.
         @type  vconstraints: dict
         """
-        raise NotImplementedError, \
-              "%s provides only a single solution" % self.__class__.__name__
+        raise NotImplementedError( \
+              "%s provides only a single solution" % self.__class__.__name__)
 
     def getSolutionIter(self, domains, constraints, vconstraints):
         """
@@ -406,8 +406,8 @@ def getSolutionIter(self, domains, constraints, vconstraints):
                              constraints affecting the given variables.
         @type  vconstraints: dict
         """
-        raise NotImplementedError, \
-              "%s doesn't provide iteration" % self.__class__.__name__
+        raise NotImplementedError( \
+              "%s doesn't provide iteration" % self.__class__.__name__)
 
 class BacktrackingSolver(Solver):
     """
@@ -522,7 +522,7 @@ def getSolutionIter(self, domains, constraints, vconstraints):
             # Push state before looking for next variable.
             queue.append((variable, values, pushdomains))
 
-        raise RuntimeError, "Can't happen"
+        raise RuntimeError("Can't happen")
 
     def getSolution(self, domains, constraints, vconstraints):
         iter = self.getSolutionIter(domains, constraints, vconstraints)
@@ -1251,7 +1251,7 @@ def __init__(self, set):
 
     def __call__(self, variables, domains, assignments, forwardcheck=False):
         # preProcess() will remove it.
-        raise RuntimeError, "Can't happen"
+        raise RuntimeError("Can't happen")
 
     def preProcess(self, variables, domains, constraints, vconstraints):
         set = self._set
@@ -1286,7 +1286,7 @@ def __init__(self, set):
 
     def __call__(self, variables, domains, assignments, forwardcheck=False):
         # preProcess() will remove it.
-        raise RuntimeError, "Can't happen"
+        raise RuntimeError("Can't happen")
 
     def preProcess(self, variables, domains, constraints, vconstraints):
         set = self._set
diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index 836a31e5..bb446739 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -28,18 +28,20 @@
 Functional Coverage features.
 
 Global variable:
-coverage_db - a coverage prefix tree (map) containing all coverage objects with name string as a key
+coverage_db - a coverage prefix tree (map) containing all coverage objects with
+              name string as a key
 
 Classes:
-CoverItem  - coverage base class, corresponds to a covergroup, created automatically
+CoverItem  - coverage base class, corresponds to a covergroup, created 
+             automatically
 CoverPoint - a cover point with bins
 CoverCross - a cover cross with references to CoverPoints
 CoverCheck - a cover point which checks only a pass/fail condition
 
 Functions:
 reportCoverage(logger, bins) - prints coverage
-coverageSection(*CoverItems) - allows for convenient definition of multiple coverage items and combines 
-  them into a single decorator
+coverageSection(*CoverItems) - allows for convenient definition of multiple 
+  coverage items and combines them into a single decorator
 
 """
 
@@ -51,85 +53,93 @@
 
 # global variable collecting coverage in a prefix tree (trie)
 coverage_db = {}
-            
+
+
 class CoverItem(object):
     """
     Class used to describe coverage groups.
     CoverItem objects are created automatically. 
     """
+
     def __init__(self, name):
         self._name = name
         self._size = 0
         self._coverage = 0
         self._parent = None
         self._children = []
-        
+
         self._threshold_callbacks = {}
         self._bins_callbacks = {}
-                
-        #check if parent exists
+
+        # check if parent exists
         if "." in name:
-            parent_name=".".join(name.split(".")[:-1])
+            parent_name = ".".join(name.split(".")[:-1])
             if not parent_name in coverage_db:
                 CoverItem(name=parent_name)
-                
+
             self._parent = coverage_db[parent_name]
             self._parent._children.append(self)
-                
+
         coverage_db[name] = self
-    
+
     def _update_coverage(self, coverage):
         current_coverage = self._coverage
         self._coverage += coverage
         if self._parent is not None:
-            self._parent._update_coverage(coverage) 
-            
-        #notify callbacks
+            self._parent._update_coverage(coverage)
+
+        # notify callbacks
         for ii in self._threshold_callbacks:
-            if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
-                self._threshold_callbacks[ii]() 
-                
+            if (ii > 100 * current_coverage / self.size and
+                ii <= 100 * self.coverage / self.size):
+                self._threshold_callbacks[ii]()
+
     def _update_size(self, size):
         self._size += size
         if self._parent is not None:
-            self._parent._update_size(size) 
-        
+            self._parent._update_size(size)
+
     def add_threshold_callback(self, callback, threshold):
         self._threshold_callbacks[threshold] = callback
-        
+
     def add_bins_callback(self, callback, bins):
         self._bins_callbacks[bins] = callback
-        
+
     @property
     def size(self):
         return self._size
-        
+
     @property
     def coverage(self):
         return self._coverage
-    
+
     @property
     def detailed_coverage(self):
         coverage = []
         for child in self._children:
             coverage.append(child.detailed_coverage)
         return coverage
-        
+
+
 class CoverPoint(CoverItem):
     """
-    Class used to create coverage points as decorators. It matches predefined bins
-    according to the rule rel(xf(args), bin) == True 
+    Class used to create coverage points as decorators. It matches predefined 
+    bins according to the rule rel(xf(args), bin) == True 
     Syntax:
     @coverage.CoverPoint(name, xf, rel, bins, weight, at_least, inj)
     Where:
     name - a CoverPoint path and name, defining its position in a coverage trie
-    xf - (optional) transformation function, which transforms arguments of the decorated function (args)
-    rel - (optional) relation function which defines bins matching relation (by default, equality operator)
+    xf - (optional) transformation function, which transforms arguments of the 
+         decorated function (args)
+    rel - (optional) relation function which defines bins matching relation (by 
+          default, equality operator)
     bins - a list of bins objects to be matched
     weight - (optional) a CoverPoint weight (by default 1)
-    at_least - (optional) defines number of hits per bin to be considered as covered (by default 1)
-    inj - (optional) defines if more than single bin can be matched at one sampling (default False)
-    
+    at_least - (optional) defines number of hits per bin to be considered as c
+               overed (by default 1)
+    inj - (optional) defines if more than single bin can be matched at one 
+          sampling (default False)
+
     Example:
     @coverage.CoverPoint(
       name = "top.parent.coverpoint", 
@@ -139,102 +149,112 @@ class CoverPoint(CoverItem):
     )
     def decorated_fun(self, arg):
       ...
-    Bin from the bins list [1,2,3,4,5] will be matched when arg/2 < bin at decorated_fun call.
+    Bin from the bins list [1,2,3,4,5] will be matched when arg/2 < bin at 
+    decorated_fun call.
     """
-    
-    #conditional Object creation, only if name not already registered
-    def __new__(cls, name, xf=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+
+    # conditional Object creation, only if name not already registered
+    def __new__(cls, name, xf=None, rel=None, bins=[], weight=1, at_least=1, 
+                inj=False):
         if name in coverage_db:
             return coverage_db[name]
         else:
             return super(CoverPoint, cls).__new__(CoverPoint)
 
-    def __init__(self, name, xf=None, rel=None, bins=[], weight=1, at_least=1, inj=False):
+    def __init__(self, name, xf=None, rel=None, bins=[], weight=1, at_least=1, 
+                 inj=False):
         if not name in coverage_db:
             CoverItem.__init__(self, name)
             self._transformation = xf
-            #equality operator is the defult bins matching relation
+            # equality operator is the defult bins matching relation
             self._relation = rel if rel is not None else operator.eq
             self._weight = weight
             self._at_least = at_least
             self._injection = inj
-                        
-            if (len(bins) != 0): 
-                self._size = self._weight*len(bins)
+
+            if (len(bins) != 0):
+                self._size = self._weight * len(bins)
                 self._hits = OrderedDict.fromkeys(bins, 0)
-            else: #if no bins specified, add one bin equal True
+            else:  # if no bins specified, add one bin equal True
                 self._size = self._weight
                 self._hits = OrderedDict.fromkeys([True], 0)
-            
-            self._decorates_method = None #determines whether decorated a bound method
-            self._trans_is_method = None #determines whether transformation function is a bound method
+
+            # determines whether decorated a bound method
+            self._decorates_method = None
+            # determines whether transformation function is a bound method
+            self._trans_is_method = None
             self._parent._update_size(self._size)
-            
-            self._new_hits = [] #list of bins hit per single function call
+
+            self._new_hits = []  # list of bins hit per single function call
 
     def __call__(self, f):
         @wraps(f)
         def _wrapped_function(*cb_args, **cb_kwargs):
-            
-            #if transformation function not defined, simply return arguments
+
+            # if transformation function not defined, simply return arguments
             if self._transformation is None:
-                def dummy_f(*cb_args): #return a tuple or single object
+                def dummy_f(*cb_args):  # return a tuple or single object
                     if len(cb_args) > 1:
                         return cb_args
                     else:
                         return cb_args[0]
                 self._transformation = dummy_f
-                
-            #for the first time only check if decorates method in the class
+
+            # for the first time only check if decorates method in the class
             if self._decorates_method is None:
                 self._decorates_method = False
                 for x in inspect.getmembers(cb_args[0]):
                     if '__func__' in dir(x[1]):
-                        #compare decorated function name with class functions
-                        self._decorates_method = f.__name__ == x[1].__func__.__name__
+                        # compare decorated function name with class functions
+                        self._decorates_method = f.__name__ == x[
+                            1].__func__.__name__
                         if self._decorates_method:
                             break
-                            
-            #for the first time only check if a transformation function is a method
+
+            # for the first time only check if a transformation function is a
+            # method
             if self._trans_is_method is None:
-                self._trans_is_method = "self" in inspect.getargspec(self._transformation).args
-            
+                self._trans_is_method = "self" in inspect.getargspec(
+                    self._transformation).args
+
             current_coverage = self.coverage
-            self._new_hits = [] 
-            
-            #if function is bound then remove "self" from the arguments list
+            self._new_hits = []
+
+            # if function is bound then remove "self" from the arguments list
             if self._decorates_method ^ self._trans_is_method:
-                result = self._transformation(*cb_args[1:]) 
+                result = self._transformation(*cb_args[1:])
             else:
                 result = self._transformation(*cb_args)
-                
-            #compare function result using relation function with matching bins
+
+            # compare function result using relation function with matching
+            # bins
             for bins in self._hits:
                 if self._relation(result, bins):
                     self._hits[bins] += 1
                     self._new_hits.append(bins)
-                    #check bins callbacks
+                    # check bins callbacks
                     if bins in self._bins_callbacks:
                         self._bins_callbacks[bins]()
-                    #if injective function, continue through all bins
+                    # if injective function, continue through all bins
                     if not self._injection:
-                        break 
-            
-            #notify parent about new coverage level
-            self._parent._update_coverage(self.coverage-current_coverage)
-            
-            #check threshold callbacks
+                        break
+
+            # notify parent about new coverage level
+            self._parent._update_coverage(self.coverage - current_coverage)
+
+            # check threshold callbacks
             for ii in self._threshold_callbacks:
-                if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
-                    self._threshold_callbacks[ii]() 
-                
+                if (ii > 100 * current_coverage / self.size and 
+                    ii <= 100 * self.coverage / self.size):
+                    self._threshold_callbacks[ii]()
+
             return f(*cb_args, **cb_kwargs)
         return _wrapped_function
-    
+
     @property
     def size(self):
         return self._size
-        
+
     @property
     def coverage(self):
         coverage = self._size
@@ -242,33 +262,45 @@ def coverage(self):
             if self._hits[ii] < self._at_least:
                 coverage -= self._weight
         return coverage
-        
+
     @property
     def detailed_coverage(self):
         return self._hits
-        
+
     @property
     def new_hits(self):
         return self._new_hits
-        
-        
+
+
 class CoverCross(CoverItem):
     """
-    Class used to create coverage crosses as decorators. It matches tuples cross-bins which are
-    Cartesian products of bins defined in CoverPoints (items).
+    Class used to create coverage crosses as decorators. It matches tuples 
+    cross-bins which are Cartesian products of bins defined in CoverPoints 
+    (items).
     Syntax:
     @coverage.CoverCross(name, items, ign_bins, weight, at_least, ign_rel)
     Where:
     name - a CoverCross path and name, defining its position in a coverage trie
-    items - a list of CoverPoints by names, to create a Cartesian product of cross-bins
+    items - a list of CoverPoints by names, to create a Cartesian product of 
+            cross-bins
     ign_bins - (optional) a list of bins to be ignored
     weight - (optional) a CoverCross weight (by default 1)
-    at_least - (optional) defines number of hits per bin to be considered as covered (by default 1)
-    ign_rel - (optional) defines a relation which applies to the ign_bins list (by default equality operator)
-    
+    at_least - (optional) defines number of hits per bin to be considered as 
+               covered (by default 1)
+    ign_rel - (optional) defines a relation which applies to the ign_bins list 
+              (by default equality operator)
+
     Example:
-    @coverage.CoverPoint(name = "top.parent.coverpoint1", xf = lambda x, y: x, bins = range(1,5))
-    @coverage.CoverPoint(name = "top.parent.coverpoint2", xf = lambda x, y: y, bins = range(1,5))
+    @coverage.CoverPoint(
+      name = "top.parent.coverpoint1", 
+      xf = lambda x, y: x, 
+      bins = range(1,5)
+    )
+    @coverage.CoverPoint(
+      name = "top.parent.coverpoint2", xf = 
+      lambda x, y: y, 
+      bins = range(1,5)
+    )
     @coverage.CoverCross(
       name = "top.parent.covercross", 
       items = ["top.parent.coverpoint1", "top.parent.coverpoint2"],
@@ -276,80 +308,85 @@ class CoverCross(CoverItem):
     )
     def decorated_fun(self, arg_a, arg_b):
       ...
-    Bin from the bins list [(1,2),(1,3)...(5,4)] will be matched when a tuple (x=arg_a, y=arg_b) 
-    sampled at decorated_fun call.
+    Bin from the bins list [(1,2),(1,3)...(5,4)] will be matched when a tuple 
+    (x=arg_a, y=arg_b) sampled at decorated_fun call.
     """
-    
-    #conditional Object creation, only if name not already registered
-    def __new__(cls, name, items = [], ign_bins = [], weight=1, at_least=1, ign_rel = None):
+
+    # conditional Object creation, only if name not already registered
+    def __new__(cls, name, items=[], ign_bins=[], weight=1, at_least=1, 
+                ign_rel=None):
         if name in coverage_db:
             return coverage_db[name]
         else:
             return super(CoverCross, cls).__new__(CoverCross)
 
-    def __init__(self, name, items = [], ign_bins = [], weight=1, at_least=1, ign_rel = None):
+    def __init__(self, name, items=[], ign_bins=[], weight=1, at_least=1, 
+                 ign_rel=None):
         if not name in coverage_db:
             CoverItem.__init__(self, name)
             self._weight = weight
             self._at_least = at_least
-            #equality operator is the defult ignore bins matching relation
+            # equality operator is the defult ignore bins matching relation
             self._relation = ign_rel if ign_rel is not None else operator.eq
             self._items = items
-            
+
             bins_lists = []
             for cp_names in self._items:
-                bins_lists.append(coverage_db[cp_names].detailed_coverage.keys())
-                
-            #a map of cross-bins, key is a tuple of bins Cartesian product
-            self._hits = dict.fromkeys(itertools.product(*bins_lists), 0) 
-            
-            #remove ignore bins from _hits map if relation is true
+                bins_lists.append(
+                    coverage_db[cp_names].detailed_coverage.keys())
+
+            # a map of cross-bins, key is a tuple of bins Cartesian product
+            self._hits = dict.fromkeys(itertools.product(*bins_lists), 0)
+
+            # remove ignore bins from _hits map if relation is true
             for x_bins in self._hits.keys():
                 for ignore_bins in ign_bins:
                     remove = True
-                    for ii in range(0,len(x_bins)):
+                    for ii in range(0, len(x_bins)):
                         if ignore_bins[ii] is not None:
                             if not self._relation(ignore_bins[ii], x_bins[ii]):
                                 remove = False
                     if remove:
                         del self._hits[x_bins]
-                        
-            self._size = self._weight*len(self._hits)            
+
+            self._size = self._weight * len(self._hits)
             self._parent._update_size(self._size)
 
     def __call__(self, f):
         @wraps(f)
         def _wrapped_function(*cb_args, **cb_kwargs):
-            
+
             current_coverage = self.coverage
-            
+
             hit_lists = []
             for cp_name in self._items:
                 hit_lists.append(coverage_db[cp_name]._new_hits)
-                
-            #a list of hit cross-bins, key is a tuple of bins Cartesian product
+
+            # a list of hit cross-bins, key is a tuple of bins Cartesian
+            # product
             for x_bins_hit in list(itertools.product(*hit_lists)):
                 if x_bins_hit in self._hits:
                     self._hits[x_bins_hit] += 1
-                    #check bins callbacks
+                    # check bins callbacks
                     if x_bins_hit in self._bins_callbacks:
                         self._bins_callbacks[x_bins_hit]()
-            
-            #notify parent about new coverage level
-            self._parent._update_coverage(self.coverage-current_coverage)
-            
-            #check threshold callbacks
+
+            # notify parent about new coverage level
+            self._parent._update_coverage(self.coverage - current_coverage)
+
+            # check threshold callbacks
             for ii in self._threshold_callbacks:
-                if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
-                    self._threshold_callbacks[ii]() 
-                
+                if (ii > 100 * current_coverage / self.size and 
+                    ii <= 100 * self.coverage / self.size):
+                    self._threshold_callbacks[ii]()
+
             return f(*cb_args, **cb_kwargs)
         return _wrapped_function
-                
+
     @property
     def size(self):
         return self._size
-        
+
     @property
     def coverage(self):
         coverage = self._size
@@ -357,23 +394,28 @@ def coverage(self):
             if self._hits[ii] < self._at_least:
                 coverage -= self._weight
         return coverage
-        
+
     @property
     def detailed_coverage(self):
         return self._hits
 
+
 class CoverCheck(CoverItem):
     """
-    Class used to create coverage checks as decorators. It is a simplified CoverPoint
-    with defined 2 bins: "PASS" and "FAIL" and f_pass() and f_fail() functions. 
+    Class used to create coverage checks as decorators. It is a simplified 
+    CoverPointwith defined 2 bins: "PASS" and "FAIL" and f_pass() and f_fail() 
+    functions. 
     Syntax:
     @coverage.CoverCheck(name, f_fail, f_pass, weight, at_least)    
     Where:
     name - a CoverCheck path and name, defining its position in a coverage trie
-    f_fail - a failure function, if returned true, a coverage level is set 0% permanently
-    f_pass - a pass function, if returned true coverage level is set 100% after (at_least) hits
+    f_fail - a failure function, if returned true, a coverage level is set 0% 
+             permanently
+    f_pass - a pass function, if returned true coverage level is set 100% after 
+             (at_least) hits
     weight - (optional) a CoverCheck weight (by default 1)
-    at_least - (optional) defines how many times f_pass needs to be satisfied (by default 1)
+    at_least - (optional) defines how many times f_pass needs to be satisfied 
+               (by default 1)
     Example:
     @coverage.CoverCheck(
       name = "top.parent.check", 
@@ -381,11 +423,12 @@ class CoverCheck(CoverItem):
       f_pass = lambda x : x < 5)
     def decorated_fun(self, arg):
       ...
-    A CoverCheck is satisfied (100% covered) when sampled arg < 5 and never sampled arg == 0.
+    A CoverCheck is satisfied (100% covered) when sampled arg < 5 and never 
+    sampled arg == 0.
     A CoverCheck is failed (0% covered) when at least once sampled arg == 0.
-      
+
     """
-    #conditional Object creation, only if name not already registered
+    # conditional Object creation, only if name not already registered
     def __new__(cls, name, f_fail, f_pass=None, weight=1, at_least=1):
         if name in coverage_db:
             return coverage_db[name]
@@ -401,113 +444,121 @@ def __init__(self, name, f_fail, f_pass=None, weight=1, at_least=1):
             self._f_fail = f_fail
             self._size = weight
             self._hits = dict.fromkeys(["PASS", "FAIL"], 0)
-            
-            self._decorates_method = None #determines whether decorated a bound method
-            self._f_pass_is_method = None #determines whether pass function is a bound method
-            self._f_fail_is_method = None #determines whether fail function is a bound method
+
+            # determines whether decorated a bound method
+            self._decorates_method = None
+            # determines whether pass function is a bound method
+            self._f_pass_is_method = None
+            # determines whether fail function is a bound method
+            self._f_fail_is_method = None
             self._parent._update_size(self._size)
 
     def __call__(self, f):
         @wraps(f)
         def _wrapped_function(*cb_args, **cb_kwargs):
-                            
-            #if pass function not defined always return True
+
+            # if pass function not defined always return True
             if self._f_pass is None:
                 def dummy_f(*cb_args):
                     return True
                 self._f_pass = dummy_f
-                            
-            #for the first time only check if decorates method in the class
+
+            # for the first time only check if decorates method in the class
             if self._decorates_method is None:
                 self._decorates_method = False
                 for x in inspect.getmembers(cb_args[0]):
                     if '__func__' in dir(x[1]):
-                        #compare decorated function name with class functions
-                        self._decorates_method = f.__name__ == x[1].__func__.__name__
+                        # compare decorated function name with class functions
+                        self._decorates_method = f.__name__ == x[
+                            1].__func__.__name__
                         if self._decorates_method:
                             break
-                            
-                            
-                            
-            #for the first time only check if a pass/fail function is a method
+
+            # for the first time only check if a pass/fail function is a method
             if self._f_pass_is_method is None and self._f_pass:
-                self._f_pass_is_method = "self" in inspect.getargspec(self._f_pass).args
+                self._f_pass_is_method = "self" in inspect.getargspec(
+                    self._f_pass).args
             if self._f_fail_is_method is None:
-                self._f_fail_is_method = "self" in inspect.getargspec(self._f_fail).args
-                
+                self._f_fail_is_method = "self" in inspect.getargspec(
+                    self._f_fail).args
+
             current_coverage = self.coverage
-                
-            #may be False (failed), True (passed) or None (undetermined)
+
+            # may be False (failed), True (passed) or None (undetermined)
             passed = None
-            
-            #if function is bound then remove "self" from the arguments list
+
+            # if function is bound then remove "self" from the arguments list
             if self._decorates_method ^ self._f_pass_is_method:
                 passed = True if self._f_pass(*cb_args[1:]) else None
             else:
                 passed = True if self._f_pass(*cb_args) else None
-                
+
             if self._decorates_method ^ self._f_fail_is_method:
                 passed = False if self._f_fail(*cb_args[1:]) else passed
             else:
                 passed = False if self._f_fail(*cb_args) else passed
-                
+
             if passed:
                 self._hits["PASS"] += 1
             elif not passed:
                 self._hits["FAIL"] += 1
-                    
+
             if passed is not None:
-                        
-                #notify parent about new coverage level
-                self._parent._update_coverage(self.coverage-current_coverage)
-                
-                #check threshold callbacks
+
+                # notify parent about new coverage level
+                self._parent._update_coverage(self.coverage - current_coverage)
+
+                # check threshold callbacks
                 for ii in self._threshold_callbacks:
-                    if (ii > 100*current_coverage/self.size and ii <= 100*self.coverage/self.size):
-                        self._threshold_callbacks[ii]() 
-                                         
-                #check bins callbacks
+                    if (ii > 100 * current_coverage / self.size and 
+                        ii <= 100 * self.coverage / self.size):
+                        self._threshold_callbacks[ii]()
+
+                # check bins callbacks
                 if "PASS" in self._bins_callbacks and passed:
-                    self._bins_callbacks["PASS"]() 
+                    self._bins_callbacks["PASS"]()
                 elif "FAIL" in self._bins_callbacks and not passed:
-                    self._bins_callbacks["FAIL"]() 
-                            
-                
+                    self._bins_callbacks["FAIL"]()
+
             return f(*cb_args, **cb_kwargs)
         return _wrapped_function
-                
+
     @property
     def size(self):
         return self._size
-        
+
     @property
     def coverage(self):
         coverage = 0
         if self._hits["FAIL"] == 0 and self._hits["PASS"] > self._at_least:
-            coverage = self._weight 
+            coverage = self._weight
         return coverage
-        
+
     @property
     def detailed_coverage(self):
         return self._hits
 
+
 def reportCoverage(logger, bins=False):
     """Prints sorted coverage with optional bins details"""
     sorted_cov = sorted(coverage_db, key=str.lower)
     for ii in sorted_cov:
-        logger ("   "*ii.count('.') + "%s : %s, coverage=%d, size=%d ", 
-          ii, 
-          coverage_db[ii], 
-          coverage_db[ii].coverage, 
-          coverage_db[ii].size
+        logger("   " * ii.count('.') + "%s : %s, coverage=%d, size=%d " % (
+            ii,
+            coverage_db[ii],
+            coverage_db[ii].coverage,
+            coverage_db[ii].size
+        )
         )
         if (type(coverage_db[ii]) is not CoverItem) & (bins):
             for jj in coverage_db[ii].detailed_coverage:
-                logger ("   "*ii.count('.') + "   BIN %s : %s", 
-                  jj, 
-                  coverage_db[ii].detailed_coverage[jj]
+                logger("   " * ii.count('.') + "   BIN %s : %s" % (
+                    jj,
+                    coverage_db[ii].detailed_coverage[jj]
+                )
                 )
 
+
 def coverageSection(*coverItems):
     """
     Combines multiple coverage items into a single decorator.
@@ -524,14 +575,15 @@ def decorated_fun(self, arg):
     """
     def nested(*decorators):
         def decorator(f):
-             for dec in reversed(*decorators):
-                  f = dec(f)
-             return f
+            for dec in reversed(*decorators):
+                f = dec(f)
+            return f
         return decorator
 
     fNested = nested(coverItems)
 
     class CoverageSection():
+
         def __call__(self, f):
             @wraps(f)
             @fNested
diff --git a/cocotb/crv.py b/cocotb/crv.py
index e5e92342..52a7acac 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -37,20 +37,24 @@
 import copy
 import itertools
 
+
 class Randomized(object):
     """
-    Base class for randomized types. Final class should contain defined random variables using addRand() 
-    method. Constraints may be added/deleted using add/delConstraint() methods. 
-    Constraint is an arbitrary function and may either return a true/false value (hard constraints) or 
-    a numeric value, which may be interpreted as soft constraints or distribution functions. Constraint 
-    function arguments must match final class attributes (random or not). Constraints may have multiple 
+    Base class for randomized types. Final class should contain defined random 
+    variables using addRand() method. Constraints may be added/deleted using 
+    add/delConstraint() methods. 
+    Constraint is an arbitrary function and may either return a true/false value
+    (hard constraints) or a numeric value, which may be interpreted as soft 
+    constraints or distribution functions. Constraint function arguments must 
+    match final class attributes (random or not). Constraints may have multiple 
     random arguments which corresponds to multi-dimensional distributions.
-    Function randomize() performs a randomization for all random variables meeting all defined  constraints. 
-    Function randomize_with() performs a randomization using additional constraint functions given in an 
-    argument.
-    Functions pre/post_randomize() are called before/after randomize and should be overloaded in a final
-    class if necessary. 
-    
+    Function randomize() performs a randomization for all random variables 
+    meeting all defined  constraints. 
+    Function randomize_with() performs a randomization using additional 
+    constraint functions given in an argument.
+    Functions pre/post_randomize() are called before/after randomize and should 
+    be overloaded in a final class if necessary. 
+
     Example:
     class FinalRandomized(Randomized)
       def __init__(self, x):
@@ -58,74 +62,89 @@ def __init__(self, x):
         self.x = x
         self.y = 0
         self.z = 0
-        addRand(y, range(10)) #define y as a random variable taking values from 0 to 9
-        addRand(z, range(5))  #define z as a random variable taking values from 0 to 4
-        addConstraint(lambda x, y: x !=y ) #a hard constraint
+        #define y as a random variable taking values from 0 to 9
+        addRand(y, range(10))
+        #define z as a random variable taking values from 0 to 4
+        addRand(z, range(5))  
+        addConstraint(lambda x, y: x !=y ) #hard constraint
         addConstraint(lambda y, z: y + z ) #multi-dimensional distribution
-        
+
     object = FinalRandomized(5)
-    object.randomize_with(lambda z : z > 3) # additional constraint to be applied
-    
-    As generating constrained random objects may involve a lot of computations, it is recommended to limit
-    random variables domains and use pre/post_randomize() methods where possible. 
+    object.randomize_with(lambda z : z > 3) #additional constraint to be applied
+
+    As generating constrained random objects may involve a lot of computations, 
+    it is recommended to limit random variables domains and use 
+    pre/post_randomize() methods where possible. 
     """
 
     def __init__(self):
-        #all random variables, map NAME -> DOMAIN
-        self._randVariables = {} 
-        #all simple constraints: functions of single random variable and optional non-random variables
-        #map VARIABLE NAME -> FUNCTION
-        self._simpleConstraints = {} 
-        #all implicit constraints: functions that requires to be resolved by a Solver
-        #map TUPLE OF VARIABLE NAMES -> FUNCTION
-        self._implConstraints = {} 
-        #all implicit distributions: functions that involve implicit random variables and single 
-        #unconstrained variable
-        #map TUPLE OF VARIABLE NAMES -> FUNCTION
-        self._implDistributions = {} 
-        #all simple distributions: functions of unconstrained random variables and non-random variables
-        #map VARIABLE NAME -> FUNCTION
-        self._simpleDistributions = {} 
-    
+        # all random variables, map NAME -> DOMAIN
+        self._randVariables = {}
+        # all simple constraints: functions of single random variable and
+        # optional non-random variables
+        # map VARIABLE NAME -> FUNCTION
+        self._simpleConstraints = {}
+        # all implicit constraints: functions that requires to be resolved by a
+        # Solver
+        # map TUPLE OF VARIABLE NAMES -> FUNCTION
+        self._implConstraints = {}
+        # all implicit distributions: functions that involve implicit random
+        # variables and singleunconstrained variable
+        # map TUPLE OF VARIABLE NAMES -> FUNCTION
+        self._implDistributions = {}
+        # all simple distributions: functions of unconstrained random variables
+        # and non-random variables
+        # map VARIABLE NAME -> FUNCTION
+        self._simpleDistributions = {}
+
     def addRand(self, var, domain=None):
         """
-        Adds a random variable to the solver. All random variables must be defined before adding any 
-        constraint. Therefore it is highly recommended to do this in an __init__ method. 
+        Adds a random variable to the solver. All random variables must be 
+        defined before adding any constraint. Therefore it is highly recommended
+        to do this in an __init__ method. 
         Syntax:
         addRand(var, domain)
         Where:
-        var - a variable name (string) corresponding to the class member variable
+        var - a variable name (str) corresponding to the class member variable
         domain - a list of all allowed values of the variable var
-        
+
         Examples:
         addRand("data", range(1024))
         addRand("delay", ["small", "medium", "high"])
         """
-        assert (not (self._simpleConstraints or self._implConstraints or self._implDistributions or
-             self._simpleDistributions)), "All random variable must be defined before adding a costraint"
-             
+        assert (not (self._simpleConstraints or
+                     self._implConstraints or
+                     self._implDistributions or
+                     self._simpleDistributions)
+                ), \
+            "All random variable must be defined before adding a constraint"
+
         if not domain:
-            domain = range(65535) #16 bit unsigned int
-                 
-        self._randVariables[var] = domain #add a variable to the map
+            domain = range(65535)  # 16 bit unsigned int
+
+        self._randVariables[var] = domain  # add a variable to the map
 
     def addConstraint(self, cstr):
         """
-        Adds a constraint function to the solver. A constraint may return a true/false or a numeric value.
-        Constraint function arguments must be valid class member names (random or not). Arguments must be
-        listed in alphabetical order. Due to calculation complexity, it is recommended to create as few 
-        constraints as possible and implement pre/post randomization methods. 
-        Each constraint is associated with its arguments being random variables, which means for each 
-        random variable combination only one constraint of the true/false type and one numeric may be 
-        defined. The latter will overwrite the existing one. For example, when class has two random 
-        variables (x,y), 6 constraint functions may be defined: boolean an numeric constraints of x, y and
-        a pair (x,y).  
+        Adds a constraint function to the solver. A constraint may return a 
+        true/false or a numeric value. Constraint function arguments must be 
+        valid class member names (random or not). Arguments must be listed in 
+        alphabetical order. Due to calculation complexity, it is recommended to 
+        create as few constraints as possible and implement pre/post 
+        randomization methods. 
+        Each constraint is associated with its arguments being random variables, 
+        which means for each random variable combination only one constraint of 
+        the true/false type and one numeric may be defined. The latter will 
+        overwrite the existing one. For example, when class has two random 
+        variables (x,y), 6 constraint functions may be defined: boolean an 
+        numeric constraints of x, y and a pair (x,y).  
         Syntax:
         (ovewritting = )addConstraint(cstr)
         Where:
         cstr - a constraint function
-        overwritting - returns an overwritten constraint or None if no overwrite happened (optional)
-        
+        overwritting - returns an overwritten constraint or None if no overwrite
+                       happened (optional)
+
         Examples:
         def highdelay_cstr(delay):
           delay == "high"
@@ -135,21 +154,24 @@ def highdelay_cstr(delay):
         addConstraint(lambda data : abs(64 - data)) 
         #hard constraint of multiple variables (some of them may be non-random):
         addConstraint(lambda x,y,z : x + y + z == 0) 
-        #soft constraint created by applying low probability density for some solutions:
-        addConstraint(lambda delay, size : 0.01 if (size < 5 & delay == "medium") else 1) 
-        #this constraint will overwrite the previously defined (lambda data : data < 128)
+        #soft constraint created by applying low probability density for some 
+        #solutions:
+        addConstraint(
+          lambda delay, size : 0.01 if (size < 5 & delay == "medium") else 1
+        ) 
+        #this constraint will overwrite the previously defined (data < 128)
         addConstraint(lambda data : data < 256)
         """
         if isinstance(cstr, constraint.Constraint):
-            #could be a Constraint object...
+            # could be a Constraint object...
             pass
         else:
             variables = inspect.getargspec(cstr).args
             assert (variables == sorted(variables)), \
-              "Variables of constraint function must be in alphabetical order"
-            
-            #determine the function type... rather unpythonic but necessary for distinction between 
-            #a constraint and a distribution
+                "Variables of constraint function must be in alphabetical order"
+
+            # determine the function type... rather unpythonic but necessary for
+            # distinction between a constraint and a distribution
             callargs = []
             rand_variables = []
             for var in variables:
@@ -158,32 +180,35 @@ def highdelay_cstr(delay):
                     callargs.append(random.choice(self._randVariables[var]))
                 else:
                     callargs.append(getattr(self, var))
-                
+
             ret = cstr(*callargs)
-            
+
             def _addToMap(_key, _map):
                 overwriting = None
                 if _key in _map:
                     overwriting = _map[_key]
                 _map[_key] = cstr
                 return overwriting
-            
+
             if type(ret) == bool:
-                #this is a constraint  
+                # this is a constraint
                 if (len(rand_variables) == 1):
-                    overwriting = _addToMap(rand_variables[0], self._simpleConstraints)
+                    overwriting = _addToMap(
+                        rand_variables[0], self._simpleConstraints)
                 else:
-                    overwriting = _addToMap(tuple(rand_variables), self._implConstraints)
+                    overwriting = _addToMap(
+                        tuple(rand_variables), self._implConstraints)
             else:
-                #this is a distribution
+                # this is a distribution
                 if (len(rand_variables) == 1):
-                    overwriting = _addToMap(rand_variables[0], self._simpleDistributions)
+                    overwriting = _addToMap(
+                        rand_variables[0], self._simpleDistributions)
                 else:
-                    overwriting = _addToMap(tuple(rand_variables), self._implDistributions)
+                    overwriting = _addToMap(
+                        tuple(rand_variables), self._implDistributions)
 
-            #print "adding " + inspect.getsource(cstr)
             return overwriting
-                    
+
     def delConstraint(self, cstr):
         """
         Deletes a constraint function.
@@ -191,18 +216,19 @@ def delConstraint(self, cstr):
         delConstraint(cstr)
         Where:
         cstr - a constraint function
-        
+
         Example:
         delConstraint(highdelay_cstr) 
         """
         if isinstance(cstr, constraint.Constraint):
-            #could be a Constraint object...
+            # could be a Constraint object...
             pass
         else:
             variables = inspect.getargspec(cstr).args
-            
-            rand_variables = [var for var in variables if var in self._randVariables]
-            
+
+            rand_variables = [
+                var for var in variables if var in self._randVariables]
+
             if (len(rand_variables) == 1):
                 if rand_variables[0] in self._simpleConstraints:
                     del self._simpleConstraints[rand_variables[0]]
@@ -217,71 +243,75 @@ def delConstraint(self, cstr):
                     del self._implDistributions[tuple(rand_variables)]
                 else:
                     assert(0), "Could not delete a constraint!"
-            
-            #print "removing " + inspect.getsource(cstr) 
-        
+
     def pre_randomize(self):
         """
-        A function called before randomize(_with)(). To be overrided in a final class if used. 
+        A function called before randomize(_with)(). To be overrided in a final 
+        class if used. 
         """
         pass
-    
+
     def post_randomize(self):
         """
-        A function called after randomize(_with)(). To be overrided in a final class if used. 
+        A function called after randomize(_with)(). To be overrided in a final 
+        class if used. 
         """
         pass
-        
+
     def randomize(self):
         """
         Randomizes a final class using only predefined constraints.
-        """        
+        """
         self.pre_randomize()
         solution = self._resolve()
         self.post_randomize()
         self._update_variables(solution)
-        
+
     def randomize_with(self, *constraints):
         """
-        Randomizes a final class using additional constraints given in an argument. Additional constraints
-        may override existing ones.
-        """                   
+        Randomizes a final class using additional constraints given in an 
+        argument. Additional constraints may override existing ones.
+        """
         overwritten_constrains = []
-        
-        #add new constraints
+
+        # add new constraints
         for cstr in constraints:
             overwritten = self.addConstraint(cstr)
             if overwritten:
                 overwritten_constrains.append(overwritten)
-        
+
         self.pre_randomize()
         solution = self._resolve()
         self.post_randomize()
         self._update_variables(solution)
-        
-        #remove new constraints
+
+        # remove new constraints
         for cstr in constraints:
             self.delConstraint(cstr)
-        
-        #add back overwritten constraints
+
+        # add back overwritten constraints
         for cstr in overwritten_constrains:
             self.addConstraint(cstr)
 
     def _resolve(self):
         """
         Resolves constraints. 
-        """   
-        #step 1: determine search space by applying simple constraints to the random variables
-        
-        randVariables = dict(self._randVariables) #we need a copy, as we will be updating domains
-        
+        """
+        # step 1: determine search space by applying simple constraints to the
+        # random variables
+
+        # we need a copy, as we will be updating domains
+        randVariables = dict(self._randVariables)
+
         for rvar in randVariables:
             domain = randVariables[rvar]
             new_domain = []
             if rvar in self._simpleConstraints:
-                f_cstr = self._simpleConstraints[rvar] #a simple constratint function to be applied
-                #check if we have non-random vars in cstr...
-                f_c_args = inspect.getargspec(f_cstr).args #arguments of the constraint function
+                # a simple constratint function to be applied
+                f_cstr = self._simpleConstraints[rvar]
+                # check if we have non-random vars in cstr...
+                # arguments of the constraint function
+                f_c_args = inspect.getargspec(f_cstr).args
                 for ii in domain:
                     f_cstr_callvals = []
                     for f_c_arg in f_c_args:
@@ -289,111 +319,120 @@ def _resolve(self):
                             f_cstr_callvals.append(ii)
                         else:
                             f_cstr_callvals.append(getattr(self, f_c_arg))
-                    #call simple constraint for each domain element        
+                    # call simple constraint for each domain element
                     if f_cstr(*f_cstr_callvals):
                         new_domain.append(ii)
-                randVariables[rvar] = new_domain #update the domain with the constrained one
-            
-        #step 2: resolve implicit constraints using external solver
-                
-        #we use external hard constraint solver here - file constraint.py
+                # update the domain with the constrained one
+                randVariables[rvar] = new_domain
+
+        # step 2: resolve implicit constraints using external solver
+
+        # we use external hard constraint solver here - file constraint.py
         problem = constraint.Problem()
-        
-        constrainedVars = [] #all random variables for the solver
-        
+
+        constrainedVars = []  # all random variables for the solver
+
         for rvars in self._implConstraints:
-            #add all random variables
+            # add all random variables
             for rvar in rvars:
                 if not rvar in constrainedVars:
                     problem.addVariable(rvar, randVariables[rvar])
                     constrainedVars.append(rvar)
-            #add constraint
-            problem.addConstraint(self._implConstraints[rvars],rvars)
-            
-        #solve problem
+            # add constraint
+            problem.addConstraint(self._implConstraints[rvars], rvars)
+
+        # solve problem
         solutions = problem.getSolutions()
-        
-        #step 3: calculate implicit ditributions for all random variables except simple distributions
-        
-        distrVars = [] #all variables that have defined distribution functions
-        dsolutions = [] #soltuions with applied distribution weights - list of maps VARIABLE -> VALUE
-        
+
+        # step 3: calculate implicit ditributions for all random variables
+        # except simple distributions
+
+        # all variables that have defined distribution functions
+        distrVars = []
+        # soltuions with applied distribution weights - list of maps VARIABLE
+        # -> VALUE
+        dsolutions = []
+
         for dvars in self._implDistributions:
-            #add all variables that have defined distribution functions
+            # add all variables that have defined distribution functions
             for dvar in dvars:
                 if dvar not in distrVars:
                     distrVars.append(dvar)
-                    
-        #all variables that have defined distributions but uncostrained
+
+        # all variables that have defined distributions but uncostrained
         ducVars = [var for var in distrVars if var not in constrainedVars]
-                     
-        #list of domains of random uncostrained variables
+
+        # list of domains of random uncostrained variables
         ducDomains = [randVariables[var] for var in ducVars]
-        
-        #Cartesian product of above
+
+        # Cartesian product of above
         ducSolutions = list(itertools.product(*ducDomains))
-        
-        #merge solutions: constrained ones and all possible distribtion values
-        for sol in solutions: 
+
+        # merge solutions: constrained ones and all possible distribtion values
+        for sol in solutions:
             for ducsol in ducSolutions:
-                dsol = dict(sol) 
+                dsol = dict(sol)
                 jj = 0
                 for var in ducVars:
                     dsol[var] = ducsol[jj]
                     jj += 1
                 dsolutions.append(dsol)
-                
+
         dsolution_weights = []
         dsolutions_reduced = []
-        
-        for dsol in dsolutions: #take each solution
+
+        for dsol in dsolutions:  # take each solution
             weight = 1.0
-            #for all defined implicit distributions
+            # for all defined implicit distributions
             for dstr in self._implDistributions:
                 f_idstr = self._implDistributions[dstr]
-                f_id_args = inspect.getargspec(f_idstr).args 
-                #all variables in solution we need to calculate weight
+                f_id_args = inspect.getargspec(f_idstr).args
+                # all variables in solution we need to calculate weight
                 f_id_callvals = []
-                for f_id_arg in f_id_args: #for each variable name
-                    if f_id_arg in dsol: #if exists in solution
-                        f_id_callvals.append(dsol[f_id_arg]) 
-                    else: #get as non-random variable
-                        f_id_callvals.append(getattr(self, f_id_arg)) 
-                #update weight of the solution - call dstribution function
-                weight = weight*f_idstr(*f_id_callvals) 
-            #do the same for simple distributions
+                for f_id_arg in f_id_args:  # for each variable name
+                    if f_id_arg in dsol:  # if exists in solution
+                        f_id_callvals.append(dsol[f_id_arg])
+                    else:  # get as non-random variable
+                        f_id_callvals.append(getattr(self, f_id_arg))
+                # update weight of the solution - call dstribution function
+                weight = weight * f_idstr(*f_id_callvals)
+            # do the same for simple distributions
             for dstr in self._simpleDistributions:
-                #but only if variable is already in the solution
-                #if it is not, it will be calculated in step 4
-                if dstr in sol: 
+                # but only if variable is already in the solution
+                # if it is not, it will be calculated in step 4
+                if dstr in sol:
                     f_sdstr = self._simpleDistributions[dstr]
-                    f_sd_args = inspect.getargspec(f_sdstr).args 
-                    #all variables in solution we need to calculate weight
+                    f_sd_args = inspect.getargspec(f_sdstr).args
+                    # all variables in solution we need to calculate weight
                     f_sd_callvals = []
-                    for f_sd_arg in f_sd_args: #for each variable name
-                        if f_sd_arg in dsol: #if exists in solution
-                            f_sd_callvals.append(dsol[f_sd_arg]) 
-                        else: #get as non-random variable
-                            f_sd_callvals.append(getattr(self, f_sd_arg)) 
-                    #update weight of the solution - call dstribution function
-                    weight = weight*f_sdstr(*f_sd_callvals) 
+                    for f_sd_arg in f_sd_args:  # for each variable name
+                        if f_sd_arg in dsol:  # if exists in solution
+                            f_sd_callvals.append(dsol[f_sd_arg])
+                        else:  # get as non-random variable
+                            f_sd_callvals.append(getattr(self, f_sd_arg))
+                    # update weight of the solution - call dstribution function
+                    weight = weight * f_sdstr(*f_sd_callvals)
             if (weight > 0.0):
                 dsolution_weights.append(weight)
-                dsolutions_reduced.append(dsol) #remove solutions with weight = 0
-                        
-        solution_choice = self._weighted_choice(dsolutions_reduced, dsolution_weights)
+                # remove solutions with weight = 0
+                dsolutions_reduced.append(dsol)
+
+        solution_choice = self._weighted_choice(
+            dsolutions_reduced, dsolution_weights)
         solution = solution_choice if solution_choice is not None else {}
-        
-        #step 4: calculate simple ditributions for remaining random variables
+
+        # step 4: calculate simple ditributions for remaining random variables
         for dvar in randVariables:
-            if not dvar in solution: #must be already unresolved variable
+            if not dvar in solution:  # must be already unresolved variable
                 domain = randVariables[dvar]
                 weights = []
                 if dvar in self._simpleDistributions:
-                    f_dstr = self._simpleDistributions[dvar] #a simple distribution to be applied
-                    #check if we have non-random vars in dstr...
-                    f_d_args = inspect.getargspec(f_dstr).args 
-                    f_d_callvals = [] #list of lists of values for function call
+                    # a simple distribution to be applied
+                    f_dstr = self._simpleDistributions[dvar]
+                    # check if we have non-random vars in dstr...
+                    f_d_args = inspect.getargspec(f_dstr).args
+                    # list of lists of values for function call
+                    f_d_callvals = []
                     for i in domain:
                         f_d_callval = []
                         for f_d_arg in f_d_args:
@@ -402,42 +441,48 @@ def _resolve(self):
                             else:
                                 f_d_callval.append(getattr(self, f_d_arg))
                         f_d_callvals.append(f_d_callval)
-                    #call distribution function for each domain element to get the weight
-                    weights = [f_dstr(*f_d_callvals_i) for f_d_callvals_i in f_d_callvals] 
+                    # call distribution function for each domain element to get
+                    # the weight
+                    weights = [f_dstr(*f_d_callvals_i)
+                               for f_d_callvals_i in f_d_callvals]
                     new_solution = self._weighted_choice(domain, weights)
                     if new_solution is not None:
-                        solution[dvar] = new_solution #append chosen value to the solution 
+                        # append chosen value to the solution
+                        solution[dvar] = new_solution
                 else:
-                    #random variable has no defined distribution function - call simple random.choice
-                    solution[dvar] = random.choice(domain) 
-        
+                    # random variable has no defined distribution function -
+                    # call simple random.choice
+                    solution[dvar] = random.choice(domain)
+
         return solution
-        
+
     def _weighted_choice(self, solutions, weights):
         try:
             import numpy
-            return numpy.random.choice(solutions,size=1,p=weights) #pick weighted random
+            # pick weighted random
+            return numpy.random.choice(solutions, size=1, p=weights)
         except:
-            #if numpy not available
+            # if numpy not available
             non_zero_weights = [x for x in weights if x > 0]
-            
+
             if not non_zero_weights:
                 return None
-            
+
             min_weight = min(non_zero_weights)
-            
+
             weighted_solutions = []
-            
+
             for x in range(len(solutions)):
-                #insert each solution to the list multiple times 
-                weighted_solutions.extend([solutions[x] for _ in range(int(weights[x]*(1.0/min_weight)))])
-              
+                # insert each solution to the list multiple times
+                weighted_solutions.extend(
+                    [solutions[x] for _ in range(
+                        int(weights[x] * (1.0 / min_weight)))
+                     ])
+
             return random.choice(weighted_solutions)
-        
+
     def _update_variables(self, solution):
-        #update class members
+        # update class members
         for var in self._randVariables:
             if var in solution:
-                setattr(self, var, solution[var])             
-        
-    
+                setattr(self, var, solution[var])
diff --git a/cocotb/crv_unittest.py b/cocotb/crv_unittest.py
index f5916d39..2bbd09d4 100644
--- a/cocotb/crv_unittest.py
+++ b/cocotb/crv_unittest.py
@@ -1,171 +1,223 @@
-
-'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
-All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification, 
-are permitted provided that the following conditions are met (The BSD 2-Clause 
-License):
-
-1. Redistributions of source code must retain the above copyright notice, 
-this list of conditions and the following disclaimer.
-
-2. Redistributions in binary form must reproduce the above copyright notice, 
-this list of conditions and the following disclaimer in the documentation and/or 
-other materials provided with the distribution.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
-DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
-
-"""
-Contrained-random verification features unittest.
-"""
-
-import unittest
-import crv
-
-
-class TestCRV(unittest.TestCase):
-    
-    class SimpleRandomized(crv.Randomized):
-        def __init__(self, x, y):
-            crv.Randomized.__init__(self)
-            self.x = 0
-            self.y = 0
-            self.size = "small"
-        
-            self.addRand("x", range(0,10))
-            self.addRand("y", range(0,10))
-            self.addRand("size", ["small", "medium", "large"])
-            
-            self.addConstraint(lambda x, y : x < y)
-
-    def test_simple_0(self):
-        print "Running test_simple_0"
-        size_hits = []
-        for i in range (10):
-            a = self.SimpleRandomized(0,0)
-            a.randomize();
-            self.assertTrue(a.x < a.y)
-            size_hits.append(a.size)
-        self.assertTrue([x in size_hits for x in["small", "medium", "large"]] == [True, True, True])
-        
-    class RandomizedTrasaction(crv.Randomized):
-        def __init__(self, address, data=0, write=False, delay=1):
-            crv.Randomized.__init__(self)
-            self.addr = address
-            self.data = data
-            self.write = write
-            self.delay1 = delay
-            self.delay2 = 0
-            self.delay3 = 0
-        
-            if data is None:
-                self.addRand("data")
-                
-            self.addRand("delay1", range(10))
-            self.addRand("delay2", range(10))
-            self.addRand("delay3", range(10))
-            self.addConstraint(lambda delay1, delay2 : delay1 < delay2)
-            self.addConstraint(lambda delay1, delay2 : 0.9 if (delay2 < 5) else 0.1)
-            self.addConstraint(lambda delay1 : 0.7 if (delay1 < 5) else 0.3)
-            self.addConstraint(lambda addr, delay1 : 0.5*delay1 if (addr == 5) else 1)
-            self.addConstraint(lambda addr, data : data <= 10000 if (addr == 0) else data <= 5000)
-            
-    def test_simple_1(self):
-        print "Running test_simple_1"
-        for i in range(10):
-            x = self.RandomizedTrasaction(i, data=None)
-            x.randomize()
-            self.assertTrue(x.delay1 < x.delay2)
-            self.assertTrue(x.data <= 10000)
-            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
-            
-    def test_randomize_with(self): 
-        print "Running test_randomize_with"
-        for i in range(10):
-            x = self.RandomizedTrasaction(i, data=None)
-            x.randomize_with(lambda delay1, delay2: delay1 == delay2 - 1)
-            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
-            self.assertTrue((x.delay2 - x.delay1) == 1)
-            self.assertTrue(x.data <= 10000)
-            
-    def test_adding_constraints(self): 
-        print "Running test_adding_constraints"
-            
-        c1 = lambda data, delay1 : 0 if (data < 10) else 1
-        c2 = lambda data, delay3 : 0.5*delay3 if (data < 20) else 2*delay3
-        c3 = lambda data : data < 50
-        
-        for i in range(5):
-            x = self.RandomizedTrasaction(i, data=None)
-            x.addConstraint(c1)
-            x.addConstraint(c2)
-            x.addConstraint(c3)
-            x.randomize()
-            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
-            self.assertTrue(x.delay1 < x.delay2)
-            self.assertTrue(x.data < 50) #added such new constraint
-            self.assertTrue(x.data > 10) #added distribution with 0 probability
-            
-    def test_deleting_constraints(self): 
-        print "Running test_deleting_constraints"
-            
-        c3 = lambda data : data < 50
-        
-        for i in range(5):
-            x = self.RandomizedTrasaction(i, data=None)
-            x.addConstraint(c3)
-            x.randomize()
-            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
-            self.assertTrue(x.delay1 < x.delay2)
-            self.assertTrue(x.data < 50) 
-            x.delConstraint(c3)
-            x.randomize()
-            print "delay1 = %d, delay2 = %d, delay3 = %d, data = %d" % (x.delay1, x.delay2, x.delay3, x.data)
-            self.assertTrue(x.delay1 < x.delay2)
-            self.assertTrue(x.data > 50)
-            
-    class RandomizedDist(crv.Randomized):
-        def __init__(self, limit, n):
-            crv.Randomized.__init__(self)
-            self.x = 0
-            self.y = 0
-            self.z = 0
-            self.n = n
-
-            self.addRand("x", range(limit))
-            self.addRand("y", range(limit))
-            self.addRand("z", range(limit))
-            
-    def test_distributions_1(self): 
-        print "Running test_distributions_1"
-            
-        d1 = lambda x: 20/(x+1)
-        d2 = lambda y: 2*y
-        d3 = lambda n, z: n*z
-        
-        x_gr_y = 0
-        
-        for i in range(1,10):
-            foo = self.RandomizedDist(limit=20*i, n=i-1)
-            foo.addConstraint(d1)
-            foo.addConstraint(d2)
-            foo.addConstraint(d3)
-            foo.randomize()
-            print "x = %d, y = %d, z = %d, n = %d" % (foo.x, foo.y, foo.z, foo.n)
-            x_gr_y = x_gr_y + 1 if (foo.x > foo.y) else x_gr_y - 1
-            if (i==1):
-                self.assertTrue(foo.z==0) #z should not be randomised as has 0 probability for each solution
-        
-        self.assertTrue(x_gr_y < 0) #x should be less than y most of the time due to decreasing distribution
-
-if __name__ == '__main__':
-    unittest.main()
+
+'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, 
+are permitted provided that the following conditions are met (The BSD 2-Clause 
+License):
+
+1. Redistributions of source code must retain the above copyright notice, 
+this list of conditions and the following disclaimer.
+
+2. Redistributions in binary form must reproduce the above copyright notice, 
+this list of conditions and the following disclaimer in the documentation and/or 
+other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
+DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
+
+"""
+Contrained-random verification features unittest.
+"""
+
+import coverage
+import unittest
+import crv
+
+
+class TestCRV(unittest.TestCase):
+
+    class SimpleRandomized(crv.Randomized):
+
+        def __init__(self, x, y):
+            crv.Randomized.__init__(self)
+            self.x = x
+            self.y = y
+            self.size = "small"
+
+            self.addRand("x", list(range(0, 10)))
+            self.addRand("y", list(range(0, 10)))
+            self.addRand("size", ["small", "medium", "large"])
+
+            self.addConstraint(lambda x, y: x < y)
+
+    def test_simple_0(self):
+        print("Running test_simple_0")
+        size_hits = []
+        for _ in range(10):
+            a = self.SimpleRandomized(0, 0)
+            a.randomize()
+            self.assertTrue(a.x < a.y)
+            size_hits.append(a.size)
+        self.assertTrue(
+            [x in size_hits for x in["small", "medium", "large"]] ==
+            [True, True, True]
+        )
+
+    class RandomizedTrasaction(crv.Randomized):
+
+        def __init__(self, address, data=0, write=False, delay=1):
+            crv.Randomized.__init__(self)
+            self.addr = address
+            self.data = data
+            self.write = write
+            self.delay1 = delay
+            self.delay2 = 0
+            self.delay3 = 0
+
+            if data is None:
+                self.addRand("data")
+
+            self.addRand("delay1", list(range(10)))
+            self.addRand("delay2", list(range(10)))
+            self.addRand("delay3", list(range(10)))
+            self.addConstraint(lambda delay1, delay2: delay1 < delay2)
+            self.addConstraint(
+                lambda delay1, delay2: 0.9 if (delay2 < 5) else 0.1
+            )
+            self.addConstraint(lambda delay1: 0.7 if (delay1 < 5) else 0.3)
+            self.addConstraint(
+                lambda addr, delay1: 0.5 * delay1 if (addr == 5) else 1
+            )
+            self.addConstraint(
+                lambda addr, data:
+                data <= 10000 if (addr == 0) else data <= 5000
+            )
+
+    def test_simple_1(self):
+        print("Running test_simple_1")
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.randomize()
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data <= 10000)
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+
+    def test_randomize_with(self):
+        print("Running test_randomize_with")
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.randomize_with(lambda delay1, delay2: delay1 == delay2 - 1)
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+            self.assertTrue((x.delay2 - x.delay1) == 1)
+            self.assertTrue(x.data <= 10000)
+
+    def test_adding_constraints(self):
+        print("Running test_adding_constraints")
+
+        c1 = lambda data, delay1: 0 if (data < 10) else 1
+        c2 = lambda data, delay3: 0.5 * delay3 if (data < 20) else 2 * delay3
+        c3 = lambda data: data < 50
+
+        for i in range(5):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(c1)
+            x.addConstraint(c2)
+            x.addConstraint(c3)
+            x.randomize()
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data < 50)  # added such new constraint
+            # added distribution with 0 probability
+            self.assertTrue(x.data > 10)
+
+    def test_deleting_constraints(self):
+        print("Running test_deleting_constraints")
+
+        c3 = lambda data: data < 50
+
+        for i in range(5):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(c3)
+            x.randomize()
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data < 50)
+            x.delConstraint(c3)
+            x.randomize()
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data > 50)
+
+    class RandomizedDist(crv.Randomized):
+
+        def __init__(self, limit, n):
+            crv.Randomized.__init__(self)
+            self.x = 0
+            self.y = 0
+            self.z = 0
+            self.n = n
+
+            self.addRand("x", list(range(limit)))
+            self.addRand("y", list(range(limit)))
+            self.addRand("z", list(range(limit)))
+
+    def test_distributions_1(self):
+        print("Running test_distributions_1")
+
+        d1 = lambda x: 20 / (x + 1)
+        d2 = lambda y: 2 * y
+        d3 = lambda n, z: n * z
+
+        x_gr_y = 0
+
+        for i in range(1, 10):
+            foo = self.RandomizedDist(limit=20 * i, n=i - 1)
+            foo.addConstraint(d1)
+            foo.addConstraint(d2)
+            foo.addConstraint(d3)
+            foo.randomize()
+            print("x = %d, y = %d, z = %d, n = %d" %
+                  (foo.x, foo.y, foo.z, foo.n))
+            x_gr_y = x_gr_y + 1 if (foo.x > foo.y) else x_gr_y - 1
+            if (i == 1):
+                # z should not be randomised as has 0 probability for each
+                # solution
+                self.assertTrue(foo.z == 0)
+
+        # x should be less than y most of the time due to decreasing
+        # distribution
+        self.assertTrue(x_gr_y < 0)
+
+    def test_cover(self):
+
+        n = 5
+
+        cover = coverage.coverageSection(
+            coverage.CoverPoint(
+                "top.c1", xf=lambda x: x.x, bins=list(range(10))),
+            coverage.CoverPoint(
+                "top.c2", xf=lambda x: x.y, bins=list(range(10))),
+            coverage.CoverCheck("top.check", f_fail=lambda x: x.n != n)
+        )
+
+        @cover()
+        def sample(x):
+            print("%d %d" % (x.x, x.y))
+
+        for _ in range(10):
+            foo = self.RandomizedDist(10, n)
+            foo.randomize()
+            sample(foo)
+
+        coverage_size = coverage.coverage_db["top"].size
+        coverage_level = coverage.coverage_db["top"].coverage
+
+        self.assertTrue(coverage_level > coverage_size / 2)  # expect >50%
+
+
+if __name__ == '__main__':
+    unittest.main()

From 3b7023c5601e7a7c1c40c019aef93f800eea19be Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Fri, 23 Sep 2016 19:02:14 +0200
Subject: [PATCH 10/13] initial version of solveOrder

---
 cocotb/crv.py          | 280 ++++++++++++++++++++++++++++++++++---------------
 cocotb/crv_unittest.py |  31 +++++-
 2 files changed, 226 insertions(+), 85 deletions(-)

diff --git a/cocotb/crv.py b/cocotb/crv.py
index 52a7acac..50dba6a5 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -34,7 +34,6 @@
 import random
 import constraint
 import inspect
-import copy
 import itertools
 
 
@@ -63,9 +62,9 @@ def __init__(self, x):
         self.y = 0
         self.z = 0
         #define y as a random variable taking values from 0 to 9
-        addRand(y, range(10))
+        addRand(y, list(range(10)))
         #define z as a random variable taking values from 0 to 4
-        addRand(z, range(5))  
+        addRand(z, list(range(5)))  
         addConstraint(lambda x, y: x !=y ) #hard constraint
         addConstraint(lambda y, z: y + z ) #multi-dimensional distribution
 
@@ -80,28 +79,35 @@ def __init__(self, x):
     def __init__(self):
         # all random variables, map NAME -> DOMAIN
         self._randVariables = {}
+        
         # all simple constraints: functions of single random variable and
         # optional non-random variables
         # map VARIABLE NAME -> FUNCTION
         self._simpleConstraints = {}
+        
         # all implicit constraints: functions that requires to be resolved by a
         # Solver
         # map TUPLE OF VARIABLE NAMES -> FUNCTION
         self._implConstraints = {}
+        
         # all implicit distributions: functions that involve implicit random
-        # variables and singleunconstrained variable
+        # variables and single unconstrained variable
         # map TUPLE OF VARIABLE NAMES -> FUNCTION
         self._implDistributions = {}
+        
         # all simple distributions: functions of unconstrained random variables
         # and non-random variables
         # map VARIABLE NAME -> FUNCTION
         self._simpleDistributions = {}
+        
+        # list of lists containing constraints solving order
+        self._solveOrder = []
 
     def addRand(self, var, domain=None):
         """
         Adds a random variable to the solver. All random variables must be 
-        defined before adding any constraint. Therefore it is highly recommended
-        to do this in an __init__ method. 
+        defined before adding any constraint. Therefore it is highly 
+        recommended to do this in an __init__ method. 
         Syntax:
         addRand(var, domain)
         Where:
@@ -109,7 +115,7 @@ def addRand(self, var, domain=None):
         domain - a list of all allowed values of the variable var
 
         Examples:
-        addRand("data", range(1024))
+        addRand("data", list(range(1024)))
         addRand("delay", ["small", "medium", "high"])
         """
         assert (not (self._simpleConstraints or
@@ -131,12 +137,12 @@ def addConstraint(self, cstr):
         valid class member names (random or not). Arguments must be listed in 
         alphabetical order. Due to calculation complexity, it is recommended to 
         create as few constraints as possible and implement pre/post 
-        randomization methods. 
+        randomization methods or use solveOrder() function.
         Each constraint is associated with its arguments being random variables, 
         which means for each random variable combination only one constraint of 
         the true/false type and one numeric may be defined. The latter will 
         overwrite the existing one. For example, when class has two random 
-        variables (x,y), 6 constraint functions may be defined: boolean an 
+        variables (x,y), 6 constraint functions may be defined: boolean and 
         numeric constraints of x, y and a pair (x,y).  
         Syntax:
         (ovewritting = )addConstraint(cstr)
@@ -162,22 +168,121 @@ def highdelay_cstr(delay):
         #this constraint will overwrite the previously defined (data < 128)
         addConstraint(lambda data : data < 256)
         """
+        
+        #just add constraint considering all random variables 
+        return self._addConstraint(cstr, self._randVariables)
+        
+        
+    def solveOrder(self, *orderedVars):
+        """
+        Defines an order of the constraints resolving. May contain variable
+        names or lists with variable names. Constraints are resolved in a given
+        order, which means for implicit constraint and distribution functions,
+        they may be treated as simple ones, as one variable could be previously
+        resolved.
+        solveOrder(*orderedVars)
+        Where:
+        orderedVars - variables that are requested to be resolved in an specific
+                      order
+        Example:
+        addRand (x, list(range(0,10)))
+        addRand (y, list(range(0,10)))
+        addRand (z, list(range(0,10)))
+        addRand (w, list(range(0,10)))
+        addConstraint(lambda x, y : x + y = 9)
+        addConstraint(lambda z : z < 5) 
+        addConstraint(lambda w : w > 5) 
+        
+        #In first step, "z" and "x" will be resolved, which means only second 
+        #constraint will be applied. In second step, remaining constrains will 
+        #be resolved with variable "x" treated as a constant. 
+        solveOrder(["x", "z"], "y"]            
+        """
+        self._solveOrder = []
+        for selRVars in orderedVars:
+            if type(selRVars) is not list:
+                self._solveOrder.append([selRVars])
+            else:
+                self._solveOrder.append(selRVars)
+
+    def delConstraint(self, cstr):
+        """
+        Deletes a constraint function.
+        Syntax:
+        delConstraint(cstr)
+        Where:
+        cstr - a constraint function
+
+        Example:
+        delConstraint(highdelay_cstr) 
+        """
+        return self._delConstraint(cstr, self._randVariables)
+
+    def pre_randomize(self):
+        """
+        A function called before randomize(_with)(). To be overrided in a final 
+        class if used. 
+        """
+        pass
+
+    def post_randomize(self):
+        """
+        A function called after randomize(_with)(). To be overrided in a final 
+        class if used. 
+        """
+        pass
+
+    def randomize(self):
+        """
+        Randomizes a final class using only predefined constraints.
+        """
+        self._randomize()
+
+    def randomize_with(self, *constraints):
+        """
+        Randomizes a final class using additional constraints given in an 
+        argument. Additional constraints may override existing ones.
+        """
+        overwritten_constrains = []
+
+        # add new constraints
+        for cstr in constraints:
+            overwritten = self.addConstraint(cstr)
+            if overwritten:
+                overwritten_constrains.append(overwritten)
+
+        self._randomize()
+
+        # remove new constraints
+        for cstr in constraints:
+            self.delConstraint(cstr)
+
+        # add back overwritten constraints
+        for cstr in overwritten_constrains:
+            self.addConstraint(cstr)
+            
+    def _addConstraint(self, cstr, rvars):
+        """
+        Adds a constraint for a specific random variables list (which determines
+        a type of a constraint - simple or implicit).
+        """        
         if isinstance(cstr, constraint.Constraint):
             # could be a Constraint object...
             pass
         else:
             variables = inspect.getargspec(cstr).args
             assert (variables == sorted(variables)), \
-                "Variables of constraint function must be in alphabetical order"
+                "Variables of a constraint function must be defined in \
+                alphabetical order"
 
             # determine the function type... rather unpythonic but necessary for
             # distinction between a constraint and a distribution
             callargs = []
             rand_variables = []
             for var in variables:
-                if var in self._randVariables:
+                if var in rvars:
                     rand_variables.append(var)
-                    callargs.append(random.choice(self._randVariables[var]))
+                    callargs.append(random.choice(rvars[var]))
                 else:
                     callargs.append(getattr(self, var))
 
@@ -190,7 +295,7 @@ def _addToMap(_key, _map):
                 _map[_key] = cstr
                 return overwriting
 
-            if type(ret) == bool:
+            if type(ret) is bool:
                 # this is a constraint
                 if (len(rand_variables) == 1):
                     overwriting = _addToMap(
@@ -208,18 +313,12 @@ def _addToMap(_key, _map):
                         tuple(rand_variables), self._implDistributions)
 
             return overwriting
-
-    def delConstraint(self, cstr):
-        """
-        Deletes a constraint function.
-        Syntax:
-        delConstraint(cstr)
-        Where:
-        cstr - a constraint function
-
-        Example:
-        delConstraint(highdelay_cstr) 
+        
+    def _delConstraint(self, cstr, rvars):
         """
+        Deletes a constraint for a specific random variables list (which 
+        determines a type of a constraint - simple or implicit).
+        """  
         if isinstance(cstr, constraint.Constraint):
             # could be a Constraint object...
             pass
@@ -227,7 +326,7 @@ def delConstraint(self, cstr):
             variables = inspect.getargspec(cstr).args
 
             rand_variables = [
-                var for var in variables if var in self._randVariables]
+                var for var in variables if var in rvars]
 
             if (len(rand_variables) == 1):
                 if rand_variables[0] in self._simpleConstraints:
@@ -239,75 +338,87 @@ def delConstraint(self, cstr):
             else:
                 if tuple(rand_variables) in self._implConstraints:
                     del self._implConstraints[tuple(rand_variables)]
-                elif tuple(rand_variables) in self._simpleDistributions:
+                elif tuple(rand_variables) in self._implDistributions:
                     del self._implDistributions[tuple(rand_variables)]
                 else:
                     assert(0), "Could not delete a constraint!"
-
-    def pre_randomize(self):
+        
+    
+    def _randomize(self):
         """
-        A function called before randomize(_with)(). To be overrided in a final 
-        class if used. 
-        """
-        pass
-
-    def post_randomize(self):
-        """
-        A function called after randomize(_with)(). To be overrided in a final 
-        class if used. 
-        """
-        pass
-
-    def randomize(self):
-        """
-        Randomizes a final class using only predefined constraints.
+        Calls _resolve and pre/post_randomize functions in given order.
         """
         self.pre_randomize()
-        solution = self._resolve()
-        self.post_randomize()
-        self._update_variables(solution)
-
-    def randomize_with(self, *constraints):
-        """
-        Randomizes a final class using additional constraints given in an 
-        argument. Additional constraints may override existing ones.
-        """
-        overwritten_constrains = []
-
-        # add new constraints
-        for cstr in constraints:
-            overwritten = self.addConstraint(cstr)
-            if overwritten:
-                overwritten_constrains.append(overwritten)
+        if not self._solveOrder:
+            #call _resolve for all random variables 
+            solution = self._resolve(self._randVariables)
+            self._update_variables(solution)
+        else:
+            remainingVars = list(self._solveOrder)
+            for selRVars in self._solveOrder:
+                remainingVars.remove(selRVars)
+                print("remaining vars")
+                print (remainingVars)
+                # a new map of random variables
+                newRandVariables = {}
+                for var in self._randVariables:
+                    if var in selRVars:
+                        newRandVariables[var] = self._randVariables[var]
+                
+                #delete all constraints recognized as implicit
+                allImplConstraints = []     
+                
+                def _deleteCstrAndUpdate(constraintsMap):
+                    to_delete = []
+                    for cstr in constraintsMap:
+                        #if a random variable is in constraint, but not in order 
+                        #list
+                        for var in cstr:
+                            if var not in selRVars and \
+                              [_ for _ in remainingVars if var not in _]:
+                                newRandVariables[var] = self._randVariables[var]  
+                                allImplConstraints.append(constraintsMap[cstr])   
+                        to_delete.append(constraintsMap[cstr])
+                    for cstr in to_delete:
+                        self.delConstraint(cstr)
+                
+                _deleteCstrAndUpdate(self._implDistributions)   
+                  
+                #add constraint but considering only limited list of random vars   
+                for cstr in allImplConstraints:
+                    self._addConstraint(cstr, newRandVariables)
+                
+                print ("newRandVariables")
+                print (newRandVariables)
+                
+                solution = self._resolve(newRandVariables)
+                self._update_variables(solution) 
+                
+                #add back everything as it was before
+                for cstr in allImplConstraints:
+                    self._delConstraint(cstr, newRandVariables)
+                    self._addConstraint(cstr, self._randVariables)
+                
+                                          
 
-        self.pre_randomize()
-        solution = self._resolve()
         self.post_randomize()
-        self._update_variables(solution)
-
-        # remove new constraints
-        for cstr in constraints:
-            self.delConstraint(cstr)
 
-        # add back overwritten constraints
-        for cstr in overwritten_constrains:
-            self.addConstraint(cstr)
-
-    def _resolve(self):
+    def _resolve(self, randomVariables):
         """
-        Resolves constraints. 
+        Resolves constraints for given random variables.
         """
+        
+        # we need a copy, as we will be updating domains
+        randVariables = dict(randomVariables)
+        
         # step 1: determine search space by applying simple constraints to the
         # random variables
 
-        # we need a copy, as we will be updating domains
-        randVariables = dict(self._randVariables)
-
         for rvar in randVariables:
             domain = randVariables[rvar]
             new_domain = []
             if rvar in self._simpleConstraints:
-                # a simple constratint function to be applied
+                # a simple constraint function to be applied
                 f_cstr = self._simpleConstraints[rvar]
                 # check if we have non-random vars in cstr...
                 # arguments of the constraint function
@@ -344,31 +455,32 @@ def _resolve(self):
         # solve problem
         solutions = problem.getSolutions()
 
-        # step 3: calculate implicit ditributions for all random variables
+        # step 3: calculate implicit distributions for all random variables
         # except simple distributions
 
         # all variables that have defined distribution functions
         distrVars = []
-        # soltuions with applied distribution weights - list of maps VARIABLE
+        # solutions with applied distribution weights - list of maps VARIABLE
         # -> VALUE
         dsolutions = []
 
+        # add all variables that have defined distribution functions
         for dvars in self._implDistributions:
             # add all variables that have defined distribution functions
             for dvar in dvars:
                 if dvar not in distrVars:
                     distrVars.append(dvar)
 
-        # all variables that have defined distributions but uncostrained
+        # all variables that have defined distributions but unconstrained
         ducVars = [var for var in distrVars if var not in constrainedVars]
 
-        # list of domains of random uncostrained variables
+        # list of domains of random unconstrained variables
         ducDomains = [randVariables[var] for var in ducVars]
 
         # Cartesian product of above
         ducSolutions = list(itertools.product(*ducDomains))
 
-        # merge solutions: constrained ones and all possible distribtion values
+        # merge solutions: constrained ones and all possible distribution values
         for sol in solutions:
             for ducsol in ducSolutions:
                 dsol = dict(sol)
@@ -394,7 +506,7 @@ def _resolve(self):
                         f_id_callvals.append(dsol[f_id_arg])
                     else:  # get as non-random variable
                         f_id_callvals.append(getattr(self, f_id_arg))
-                # update weight of the solution - call dstribution function
+                # update weight of the solution - call distribution function
                 weight = weight * f_idstr(*f_id_callvals)
             # do the same for simple distributions
             for dstr in self._simpleDistributions:
@@ -410,7 +522,7 @@ def _resolve(self):
                             f_sd_callvals.append(dsol[f_sd_arg])
                         else:  # get as non-random variable
                             f_sd_callvals.append(getattr(self, f_sd_arg))
-                    # update weight of the solution - call dstribution function
+                    # update weight of the solution - call distribution function
                     weight = weight * f_sdstr(*f_sd_callvals)
             if (weight > 0.0):
                 dsolution_weights.append(weight)
@@ -421,7 +533,7 @@ def _resolve(self):
             dsolutions_reduced, dsolution_weights)
         solution = solution_choice if solution_choice is not None else {}
 
-        # step 4: calculate simple ditributions for remaining random variables
+        # step 4: calculate simple distributions for remaining random variables
         for dvar in randVariables:
             if not dvar in solution:  # must be already unresolved variable
                 domain = randVariables[dvar]
diff --git a/cocotb/crv_unittest.py b/cocotb/crv_unittest.py
index 2bbd09d4..47a1dec3 100644
--- a/cocotb/crv_unittest.py
+++ b/cocotb/crv_unittest.py
@@ -151,6 +151,18 @@ def test_deleting_constraints(self):
                   (x.delay1, x.delay2, x.delay3, x.data))
             self.assertTrue(x.delay1 < x.delay2)
             self.assertTrue(x.data > 50)
+            
+    def test_solve_order(self):
+        print("Running test_solve_order")
+
+        for i in range(5):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.solveOrder("delay1", ["delay2", "delay3"])
+            x.randomize()
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))
+            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.data < 50)         
 
     class RandomizedDist(crv.Randomized):
 
@@ -160,10 +172,15 @@ def __init__(self, limit, n):
             self.y = 0
             self.z = 0
             self.n = n
+            self.e_pr = False
 
             self.addRand("x", list(range(limit)))
             self.addRand("y", list(range(limit)))
             self.addRand("z", list(range(limit)))
+            
+        def post_randomize(self):
+            if self.e_pr:
+                self.n = self.x + self.y + self.z + self.n
 
     def test_distributions_1(self):
         print("Running test_distributions_1")
@@ -193,7 +210,7 @@ def test_distributions_1(self):
         self.assertTrue(x_gr_y < 0)
 
     def test_cover(self):
-
+        print("Running test_cover")
         n = 5
 
         cover = coverage.coverageSection(
@@ -217,7 +234,19 @@ def sample(x):
         coverage_level = coverage.coverage_db["top"].coverage
 
         self.assertTrue(coverage_level > coverage_size / 2)  # expect >50%
+        
+    def test_post_randomize(self):
+        print("Running test_post_randomize")
 
+        n = 5
+        foo = self.RandomizedDist(10, n)
+        foo.e_pr = True #enable post-randomize
+        for _ in range(5):
+            foo.randomize()
+            print("x = %d, y = %d, z = %d, n = %d" %
+                  (foo.x, foo.y, foo.z, foo.n))
+            
+        self.assertTrue(foo.n > 5)
 
 if __name__ == '__main__':
     unittest.main()

From 4c05b37eebbddf9278f579431a54e65eabcb48f6 Mon Sep 17 00:00:00 2001
From: mciepluc <mciepluc@gmail.com>
Date: Sat, 24 Sep 2016 14:03:37 +0200
Subject: [PATCH 11/13] fixed solveOrder, added some tests

---
 cocotb/coverage.py     |  19 ++-----
 cocotb/crv.py          | 149 ++++++++++++++++++++++++++++++++-----------------
 cocotb/crv_unittest.py |  85 +++++++++++++++++++---------
 3 files changed, 161 insertions(+), 92 deletions(-)

diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index bb446739..9fdf45a7 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -573,23 +573,12 @@ def coverageSection(*coverItems):
     def decorated_fun(self, arg):
       ...
     """
-    def nested(*decorators):
-        def decorator(f):
+    def _nested(*decorators):
+        def _decorator(f):
             for dec in reversed(*decorators):
                 f = dec(f)
             return f
-        return decorator
+        return _decorator
 
-    fNested = nested(coverItems)
-
-    class CoverageSection():
-
-        def __call__(self, f):
-            @wraps(f)
-            @fNested
-            def _wrapped_function(*cb_args, **cb_kwargs):
-                return f(*cb_args, **cb_kwargs)
-            return _wrapped_function
-
-    return CoverageSection
+    return _nested(coverItems)
 
diff --git a/cocotb/crv.py b/cocotb/crv.py
index 50dba6a5..dec1748b 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -25,7 +25,7 @@
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
 
 """
-Contrained-random verification features.
+Constrained-random verification features.
 
 Classes:
 Randomized - base class for objects intended to contain random variables
@@ -36,7 +36,6 @@
 import inspect
 import itertools
 
-
 class Randomized(object):
     """
     Base class for randomized types. Final class should contain defined random 
@@ -53,6 +52,9 @@ class Randomized(object):
     constraint functions given in an argument.
     Functions pre/post_randomize() are called before/after randomize and should 
     be overloaded in a final class if necessary. 
+    If a hard constraint cannot be resolved, an exception is thrown. If a soft
+    constraint cannot be resolved (all acceptable solutions have 0 probability)
+    a variable value is not being randomized. 
 
     Example:
     class FinalRandomized(Randomized)
@@ -75,7 +77,6 @@ def __init__(self, x):
     it is recommended to limit random variables domains and use 
     pre/post_randomize() methods where possible. 
     """
-
     def __init__(self):
         # all random variables, map NAME -> DOMAIN
         self._randVariables = {}
@@ -100,7 +101,7 @@ def __init__(self):
         # map VARIABLE NAME -> FUNCTION
         self._simpleDistributions = {}
         
-        # list of lists containing constraints solving order
+        # list of lists containing random variables solving order
         self._solveOrder = []
 
     def addRand(self, var, domain=None):
@@ -172,14 +173,13 @@ def highdelay_cstr(delay):
         #just add constraint considering all random variables 
         return self._addConstraint(cstr, self._randVariables)
         
-        
     def solveOrder(self, *orderedVars):
         """
         Defines an order of the constraints resolving. May contain variable
         names or lists with variable names. Constraints are resolved in a given
         order, which means for implicit constraint and distribution functions,
-        they may be treated as simple ones, as one variable could be previously
-        resolved.
+        they may be treated as simple ones, as one some variables could be 
+        already resolved.
         solveOrder(*orderedVars)
         Where:
         orderedVars - variables that are requested to be resolved in an specific
@@ -191,12 +191,13 @@ def solveOrder(self, *orderedVars):
         addRand (w, list(range(0,10)))
         addConstraint(lambda x, y : x + y = 9)
         addConstraint(lambda z : z < 5) 
-        addConstraint(lambda w : w > 5) 
-        
-        #In first step, "z" and "x" will be resolved, which means only second 
-        #constraint will be applied. In second step, remaining constrains will 
-        #be resolved with variable "x" treated as a constant. 
-        solveOrder(["x", "z"], "y"]            
+        addConstraint(lambda w : w > 5)
+         
+        solveOrder(["x", "z"], "y"] 
+        #In first step, "z", "x" and "w" will be resolved, which means only 
+        #second  and third constraint will be applied. In second step, first 
+        #constraint will be resolved as it was requested to solve "y" after "x"
+        #and "z". "x" will be treated as a constant in this case.      
         """
         self._solveOrder = []
         for selRVars in orderedVars:
@@ -220,14 +221,14 @@ def delConstraint(self, cstr):
 
     def pre_randomize(self):
         """
-        A function called before randomize(_with)(). To be overrided in a final 
+        A function called before randomize(_with)(). To be overridden in a final 
         class if used. 
         """
         pass
 
     def post_randomize(self):
         """
-        A function called after randomize(_with)(). To be overrided in a final 
+        A function called after randomize(_with)(). To be overridden in a final 
         class if used. 
         """
         pass
@@ -346,7 +347,8 @@ def _delConstraint(self, cstr, rvars):
     
     def _randomize(self):
         """
-        Calls _resolve and pre/post_randomize functions in given order.
+        Calls _resolve and pre/post_randomize functions with respect to defined 
+        variables resolving order.
         """
         self.pre_randomize()
         if not self._solveOrder:
@@ -354,53 +356,89 @@ def _randomize(self):
             solution = self._resolve(self._randVariables)
             self._update_variables(solution)
         else:
-            remainingVars = list(self._solveOrder)
+            
+            #list of random variables names
+            remainingRVars = list(self._randVariables.keys())
+            
+            #list of resolved random variables names 
+            resolvedRVars = []
+            
+            #list of random variables with defined solve order
+            remainingOrderedRVars = [item for sublist in self._solveOrder 
+                                     for item in sublist]
+            
+            allConstraints = [] # list of functions (all constraints and dstr)
+            allConstraints.extend([self._implConstraints[_] 
+                               for _ in self._implConstraints])
+            allConstraints.extend([self._implDistributions[_] 
+                               for _ in self._implDistributions])
+            allConstraints.extend([self._simpleConstraints[_] 
+                               for _ in self._simpleConstraints])
+            allConstraints.extend([self._simpleDistributions[_] 
+                               for _ in self._simpleDistributions])
+            
             for selRVars in self._solveOrder:
-                remainingVars.remove(selRVars)
-                print("remaining vars")
-                print (remainingVars)
+                  
+                #step 1: determine all variables to be solved at this stage
+                actualRVars = list(selRVars) #add selected
+                for rvar in actualRVars:
+                    remainingOrderedRVars.remove(rvar) #remove selected
+                    remainingRVars.remove(rvar) #remove selected
+                
+                #if implicit constraint requires a variable which is not given
+                #at this stage, it will be resolved later
+                for rvar in remainingRVars:
+                    rvar_unused = True
+                    for c_vars in self._implConstraints:
+                        if rvar in c_vars:
+                            rvar_unused = False
+                    for d_vars in self._implDistributions:
+                        if rvar in d_vars:
+                            rvar_unused = False
+                    if rvar_unused and not rvar in remainingOrderedRVars:
+                        actualRVars.append(rvar)
+                        remainingRVars.remove(rvar)
+                
                 # a new map of random variables
                 newRandVariables = {}
                 for var in self._randVariables:
-                    if var in selRVars:
+                    if var in actualRVars:
                         newRandVariables[var] = self._randVariables[var]
                 
-                #delete all constraints recognized as implicit
-                allImplConstraints = []     
-                
-                def _deleteCstrAndUpdate(constraintsMap):
-                    to_delete = []
-                    for cstr in constraintsMap:
-                        #if a random variable is in constraint, but not in order 
-                        #list
-                        for var in cstr:
-                            if var not in selRVars and \
-                              [_ for _ in remainingVars if var not in _]:
-                                newRandVariables[var] = self._randVariables[var]  
-                                allImplConstraints.append(constraintsMap[cstr])   
-                        to_delete.append(constraintsMap[cstr])
-                    for cstr in to_delete:
-                        self.delConstraint(cstr)
-                
-                _deleteCstrAndUpdate(self._implDistributions)   
-                  
-                #add constraint but considering only limited list of random vars   
-                for cstr in allImplConstraints:
-                    self._addConstraint(cstr, newRandVariables)
+                #step 2: select only valid constraints at this stage
                 
-                print ("newRandVariables")
-                print (newRandVariables)
+                #delete all constraints and add back but considering only 
+                #limited list of random vars
+                actualCstr = []
+                for f_cstr in allConstraints:
+                    self.delConstraint(f_cstr)
+                    f_cstr_args = inspect.getargspec(f_cstr).args
+                    #add only constraints containing actualRVars but not
+                    #remainingRVars
+                    add_cstr = True
+                    for var in f_cstr_args:
+                        if (var in self._randVariables and 
+                            not var in resolvedRVars and
+                            (not var in actualRVars or var in remainingRVars)
+                            ):
+                            add_cstr = False
+                    if add_cstr:                      
+                        self._addConstraint(f_cstr, newRandVariables)
+                        actualCstr.append(f_cstr)
                 
+                #call _resolve for all random variables 
                 solution = self._resolve(newRandVariables)
                 self._update_variables(solution) 
                 
-                #add back everything as it was before
-                for cstr in allImplConstraints:
-                    self._delConstraint(cstr, newRandVariables)
-                    self._addConstraint(cstr, self._randVariables)
+                resolvedRVars.extend(actualRVars)
+                
+                #add back everything as it was before this stage
+                for f_cstr in actualCstr:
+                    self._delConstraint(f_cstr, newRandVariables)
+                    
+                for f_cstr in allConstraints:  
+                    self._addConstraint(f_cstr, self._randVariables)
                 
-                                          
-
         self.post_randomize()
 
     def _resolve(self, randomVariables):
@@ -454,6 +492,9 @@ def _resolve(self, randomVariables):
 
         # solve problem
         solutions = problem.getSolutions()
+        
+        if len(solutions) < len(constrainedVars):
+            raise Exception("Could nor resolve implicit constraints!")
 
         # step 3: calculate implicit distributions for all random variables
         # except simple distributions
@@ -569,6 +610,9 @@ def _resolve(self, randomVariables):
         return solution
 
     def _weighted_choice(self, solutions, weights):
+        """
+        Gets a solution from the list with defined weights.
+        """
         try:
             import numpy
             # pick weighted random
@@ -594,6 +638,9 @@ def _weighted_choice(self, solutions, weights):
             return random.choice(weighted_solutions)
 
     def _update_variables(self, solution):
+        """
+        Updates members of the final class after randomization.
+        """
         # update class members
         for var in self._randVariables:
             if var in solution:
diff --git a/cocotb/crv_unittest.py b/cocotb/crv_unittest.py
index 47a1dec3..c6d19368 100644
--- a/cocotb/crv_unittest.py
+++ b/cocotb/crv_unittest.py
@@ -79,25 +79,25 @@ def __init__(self, address, data=0, write=False, delay=1):
             self.addRand("delay1", list(range(10)))
             self.addRand("delay2", list(range(10)))
             self.addRand("delay3", list(range(10)))
-            self.addConstraint(lambda delay1, delay2: delay1 < delay2)
-            self.addConstraint(
-                lambda delay1, delay2: 0.9 if (delay2 < 5) else 0.1
-            )
-            self.addConstraint(lambda delay1: 0.7 if (delay1 < 5) else 0.3)
-            self.addConstraint(
-                lambda addr, delay1: 0.5 * delay1 if (addr == 5) else 1
-            )
-            self.addConstraint(
-                lambda addr, data:
-                data <= 10000 if (addr == 0) else data <= 5000
-            )
+            
+            c1 = lambda delay1, delay2: delay1 <= delay2
+            d1 = lambda delay1, delay2: 0.9 if (delay2 < 5) else 0.1
+            d2 = lambda addr, delay1: 0.5 * delay1 if (addr == 5) else 1
+            d3 = lambda delay1: 0.7 if (delay1 < 5) else 0.3
+            c2 = lambda addr, data: data < 10000 if (addr == 0) else data < 5000
+            
+            self.addConstraint(c1)
+            self.addConstraint(c2)
+            self.addConstraint(d1)
+            self.addConstraint(d2)
+            self.addConstraint(d3)
 
     def test_simple_1(self):
         print("Running test_simple_1")
         for i in range(10):
             x = self.RandomizedTrasaction(i, data=None)
             x.randomize()
-            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.delay1 <= x.delay2)
             self.assertTrue(x.data <= 10000)
             print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
                   (x.delay1, x.delay2, x.delay3, x.data))
@@ -115,19 +115,19 @@ def test_randomize_with(self):
     def test_adding_constraints(self):
         print("Running test_adding_constraints")
 
-        c1 = lambda data, delay1: 0 if (data < 10) else 1
-        c2 = lambda data, delay3: 0.5 * delay3 if (data < 20) else 2 * delay3
-        c3 = lambda data: data < 50
+        c3 = lambda data, delay1: 0 if (data < 10) else 1
+        c4 = lambda data, delay3: 0.5 * delay3 if (data < 20) else 2 * delay3
+        c5 = lambda data: data < 50
 
         for i in range(5):
             x = self.RandomizedTrasaction(i, data=None)
-            x.addConstraint(c1)
-            x.addConstraint(c2)
             x.addConstraint(c3)
+            x.addConstraint(c4)
+            x.addConstraint(c5)
             x.randomize()
             print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
                   (x.delay1, x.delay2, x.delay3, x.data))
-            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.delay1 <= x.delay2)
             self.assertTrue(x.data < 50)  # added such new constraint
             # added distribution with 0 probability
             self.assertTrue(x.data > 10)
@@ -143,26 +143,54 @@ def test_deleting_constraints(self):
             x.randomize()
             print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
                   (x.delay1, x.delay2, x.delay3, x.data))
-            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.delay1 <= x.delay2)
             self.assertTrue(x.data < 50)
             x.delConstraint(c3)
             x.randomize()
             print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
                   (x.delay1, x.delay2, x.delay3, x.data))
-            self.assertTrue(x.delay1 < x.delay2)
+            self.assertTrue(x.delay1 <= x.delay2)
             self.assertTrue(x.data > 50)
             
     def test_solve_order(self):
         print("Running test_solve_order")
 
-        for i in range(5):
+        for i in range(10):
             x = self.RandomizedTrasaction(i, data=None)
             x.solveOrder("delay1", ["delay2", "delay3"])
             x.randomize()
             print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
                   (x.delay1, x.delay2, x.delay3, x.data))
-            self.assertTrue(x.delay1 < x.delay2)
-            self.assertTrue(x.data < 50)         
+            self.assertTrue(x.delay1 <= x.delay2) 
+            
+    def test_cannot_resolve(self):
+        print("Running test_cannot_resolve")
+
+        c3 = lambda delay2, delay3: delay3 > delay2
+        c4 = lambda delay1: delay1 == 9
+
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(c3)
+            x.addConstraint(c4)
+            try:
+                x.randomize()
+                self.assertTrue(0) 
+            except Exception:
+                self.assertTrue(1)     
+                
+    def test_zero_probability(self):
+        print("Running test_cannot_resolve")
+
+        d4 = lambda delay2: 0 if delay2 < 10 else 1
+
+        for i in range(10):
+            x = self.RandomizedTrasaction(i, data=None)
+            x.addConstraint(d4)
+            x.randomize()
+            print("delay1 = %d, delay2 = %d, delay3 = %d, data = %d" %
+                  (x.delay1, x.delay2, x.delay3, x.data))  
+            self.assertTrue(x.delay2 == 0) 
 
     class RandomizedDist(crv.Randomized):
 
@@ -221,9 +249,10 @@ def test_cover(self):
             coverage.CoverCheck("top.check", f_fail=lambda x: x.n != n)
         )
 
-        @cover()
+        @cover
         def sample(x):
-            print("%d %d" % (x.x, x.y))
+            print("x = %d, y = %d, z = %d, n = %d" %
+                  (foo.x, foo.y, foo.z, foo.n))
 
         for _ in range(10):
             foo = self.RandomizedDist(10, n)
@@ -250,3 +279,7 @@ def test_post_randomize(self):
 
 if __name__ == '__main__':
     unittest.main()
+    #suite = unittest.TestSuite()
+    #suite.addTest(TestCRV('test_cover'))
+    #unittest.TextTestRunner().run(suite)
+

From 6390a8d4f05bb69be2e8706308affafa8ac0514f Mon Sep 17 00:00:00 2001
From: Marek Cieplucha <m.cieplucha@imio.pw.edu.pl>
Date: Sat, 24 Sep 2016 17:23:48 +0200
Subject: [PATCH 12/13] moved unittest to cocotb/tests

---
 tests/test_cases/test_crv/Makefile                 | 33 ++++++++++++++++++++++
 .../test_cases/test_crv}/crv_unittest.py           |  8 +++---
 tests/test_cases/test_crv/test_crv.py              | 12 ++++++++
 3 files changed, 49 insertions(+), 4 deletions(-)
 create mode 100644 tests/test_cases/test_crv/Makefile
 rename {cocotb => tests/test_cases/test_crv}/crv_unittest.py (96%)
 create mode 100644 tests/test_cases/test_crv/test_crv.py

diff --git a/tests/test_cases/test_crv/Makefile b/tests/test_cases/test_crv/Makefile
new file mode 100644
index 00000000..efb77960
--- /dev/null
+++ b/tests/test_cases/test_crv/Makefile
@@ -0,0 +1,33 @@
+###############################################################################
+# Copyright (c) 2013 Potential Ventures Ltd
+# Copyright (c) 2013 SolarFlare Communications Inc
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are met:
+#     * Redistributions of source code must retain the above copyright
+#       notice, this list of conditions and the following disclaimer.
+#     * Redistributions in binary form must reproduce the above copyright
+#       notice, this list of conditions and the following disclaimer in the
+#       documentation and/or other materials provided with the distribution.
+#     * Neither the name of Potential Ventures Ltd,
+#       SolarFlare Communications Inc nor the
+#       names of its contributors may be used to endorse or promote products
+#       derived from this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+# DISCLAIMED. IN NO EVENT SHALL POTENTIAL VENTURES LTD BE LIABLE FOR ANY
+# DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+# (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+# ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+###############################################################################
+
+
+include ../../designs/sample_module/Makefile
+
+MODULE = test_crv
diff --git a/cocotb/crv_unittest.py b/tests/test_cases/test_crv/crv_unittest.py
similarity index 96%
rename from cocotb/crv_unittest.py
rename to tests/test_cases/test_crv/crv_unittest.py
index c6d19368..5d5bf0dc 100644
--- a/cocotb/crv_unittest.py
+++ b/tests/test_cases/test_crv/crv_unittest.py
@@ -25,13 +25,13 @@
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. '''
 
 """
-Contrained-random verification features unittest.
+Constrained-random verification features unittest.
 """
+import cocotb
+from cocotb import crv
+from cocotb import coverage
 
-import coverage
 import unittest
-import crv
-
 
 class TestCRV(unittest.TestCase):
 
diff --git a/tests/test_cases/test_crv/test_crv.py b/tests/test_cases/test_crv/test_crv.py
new file mode 100644
index 00000000..6175e26d
--- /dev/null
+++ b/tests/test_cases/test_crv/test_crv.py
@@ -0,0 +1,12 @@
+
+import cocotb
+import unittest
+import crv_unittest
+from cocotb.triggers import Timer
+
+@cocotb.test()
+def test_crv(dut):
+    suite = unittest.TestSuite()
+    suite.addTests(unittest.TestLoader().loadTestsFromModule(crv_unittest))
+    unittest.TextTestRunner().run(suite)
+    yield Timer(10)

From 61c53449b6996e6f56023df762b05573d040a751 Mon Sep 17 00:00:00 2001
From: Marek Cieplucha <m.cieplucha@imio.pw.edu.pl>
Date: Sat, 2 Sep 2017 15:54:07 +0200
Subject: [PATCH 13/13] maintenance commit - minor fixes

---
 cocotb/coverage.py | 4 ++--
 cocotb/crv.py      | 4 ++--
 2 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/cocotb/coverage.py b/cocotb/coverage.py
index 9fdf45a7..472a03f5 100644
--- a/cocotb/coverage.py
+++ b/cocotb/coverage.py
@@ -1,5 +1,5 @@
 
-'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+'''Copyright (c) 2017, Marek Cieplucha, https://github.com/mciepluc
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, 
@@ -569,7 +569,7 @@ def coverageSection(*coverItems):
       ...
     )
     ...
-    @my_coverage()
+    @my_coverage
     def decorated_fun(self, arg):
       ...
     """
diff --git a/cocotb/crv.py b/cocotb/crv.py
index dec1748b..469b3dd1 100644
--- a/cocotb/crv.py
+++ b/cocotb/crv.py
@@ -1,5 +1,5 @@
 
-'''Copyright (c) 2016, Marek Cieplucha, https://github.com/mciepluc
+'''Copyright (c) 2017, Marek Cieplucha, https://github.com/mciepluc
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, 
@@ -493,7 +493,7 @@ def _resolve(self, randomVariables):
         # solve problem
         solutions = problem.getSolutions()
         
-        if len(solutions) < len(constrainedVars):
+        if (len(solutions) == 0) & (len(constrainedVars) > 0):
             raise Exception("Could nor resolve implicit constraints!")
 
         # step 3: calculate implicit distributions for all random variables
